<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[ReactNativeNode]]></title>
      <url>%2F2017%2F07%2F05%2F2017-07-05-reactNative-node-2%2F</url>
      <content type="text"><![CDATA[Print: Entry, “:CFBundleIdentifier”, Does Not Exist在终端执行如下命令时：react-native run-ios 报如下错误：1234567Failed to install the requested applicationAn application bundle was not found at the provided path.Provide a valid path to the desired application bundle.Print: Entry, ":CFBundleIdentifier", Does Not ExistCommand failed: /usr/libexec/PlistBuddy -c Print:CFBundleIdentifier build/Build/Products/Debug-iphonesimulator/ReactNativexx.app/Info.plistPrint: Entry, ":CFBundleIdentifier", Does Not Exist 问题解决：这是经过各种尝试后得出的结果了，查看的下面的链接，给出的前几个方法结过测试都不能解决我的问题，只有下面的的方法是可以的 解决步骤： 首先删除node_modules 修改package.json中react-native的版本为0.44.3 react为16.0.0-alpha.6 执行npm install react-native run-ios 就可以了 问题参考链接：http://www.jianshu.com/p/98c8f2a970eb]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS应用内多语言切换]]></title>
      <url>%2F2017%2F06%2F12%2F207-06-12-InAppMoreLanguage%2F</url>
      <content type="text"><![CDATA[效果如下图：本文主要是使用StoryBoard以及代码的形式实现App内多语言的切换 具体步骤此处不多贴 Demo下载请点击下面链接Demo下载 笔者在做此Demo的过程中遇到如下问题：1、在更换语言后，TabBar及一些其它View并未及时变更成新选择的语言显示由于并没有找到其它较好的方法，此处暂时使用延时加载来解决【哪位仁兄知道更好的解决办法，麻烦告知一下，谢谢】 2、解决了即使更新语言的问题，由于我是使用rootView来重新加载，使用延时会有黑屏一闪而过由于并没有找到其它较好的方法，此处使用中间Controller来解决【哪位仁兄知道更好的解决办法，麻烦告知一下，谢谢】 注意：在多语言的App内，使用的显示字符串需要用 NSLocalizedStringNSLocalizedString(@”显示字符串”, nil); 使用StoryBoard的时候，笔者是先去将所有布局弄好，在去设置多个语言，因为此处会自动生成相应的语言文件以及内部的key 具体代码实现【此处要是看Demo，就可以省略了】切换语言12345678910111213141516171819- (void)changeLanguageTo:(NSString *)language &#123; //中文【简】 //language = @"zh-Hans"; //英文 //language = @"en"; // 设置语言 [NSBundle performSelector:@selector(setLanguage:) withObject:language afterDelay:0]; // 然后将设置好的语言存储好，下次进来直接加载 [[NSUserDefaults standardUserDefaults] setObject:language forKey:@"myLanguage"]; [[NSUserDefaults standardUserDefaults] synchronize]; // 重新加载，使用用户选择的语言，如果不添加延迟，像tabbar等个别view会加载不到用户选择的语言 AppDelegate *appDele = (AppDelegate*)[UIApplication sharedApplication].delegate; [appDele refreshRootViewCtrl];&#125; 这个Category是从网上找的，由于时间较长，未能找到具体出处12345678910111213141516171819202122232425262728#import "NSBundle+IRLanguage.h"#import &lt;objc/runtime.h&gt;static const char _bundle = 0;@interface BundleEx : NSBundle@end@implementation BundleEx- (NSString *)localizedStringForKey:(NSString *)key value:(NSString *)value table:(NSString *)tableName &#123; NSBundle *bundle = objc_getAssociatedObject(self, &amp;_bundle); return bundle ? [bundle localizedStringForKey:key value:value table:tableName] : [super localizedStringForKey:key value:value table:tableName];&#125;@end@implementation NSBundle (Language)+ (void)setLanguage:(NSString *)language &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; object_setClass([NSBundle mainBundle], [BundleEx class]); &#125;); objc_setAssociatedObject([NSBundle mainBundle], &amp;_bundle, language ? [NSBundle bundleWithPath:[[NSBundle mainBundle] pathForResource:language ofType:@"lproj"]] : nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[macOS实用工具]]></title>
      <url>%2F2017%2F05%2F11%2F17-05-11-macOS-tools%2F</url>
      <content type="text"><![CDATA[macOS下的几个不太方便下载的软件 笔者下的几个软件，是从各各网站上收集而来 能找到出处的有：http://xclient.info/http://www.sdifenzhou.com 下面是笔者在相关官网找的一些说明和使用的一些心得，并不是所有功能都有使用过，说的不对的地方欢迎指出 截图Snip：简单高效的截图工具 免费的 官方地址 点击下载licecap：是一款屏幕录制工具 持导出 GIF 动画图片格式,轻量级、使用简单,录制过程中可以随意改变录屏范围 点击下载Annotate：一款非常有趣的图片注释软件 截图，可以方便的在截取的图片进行编译【 支持短时间录制屏幕 】 点击下载 PhotoShop/PxCookPhotoShop：图像处理软件 点击下载 PxCook：切图标记利器 点击下载 笔者主要用他来做一些素材的导出，在图片上标记字号，颜色等 笔者使用PxCook进行素材导出是与PhotoShop相结合使用的具体步骤 Sublime Text 3Sublime Text 3： 点击下载 macOS配制SublimeText3运行JavaScript]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python之scrapy抓虫框架]]></title>
      <url>%2F2017%2F05%2F10%2F17-05-10-python-scrapy-cnblogs%2F</url>
      <content type="text"><![CDATA[此文章使用 macOS Sierra]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IRCategoryCollection]]></title>
      <url>%2F2017%2F05%2F10%2F17-05-10-category-collection%2F</url>
      <content type="text"><![CDATA[IRCategoryCollection 功能说明整合category 此库只是整合Category，方便多个项目重复使用有些category是由其它作者提供的，由于时间过长，有些原文链接已经找不到了， 原文链接：UIButton+IRImageTitleSpacing： https://github.com/mokong/MKButtonStyle原文名字叫 UIButton+ImageTitleSpacing 为了避免重复发生，添加了IR前缀 大致包括如下： NSString字符串【NSString】： 【 IRVerify 】验证 【 IRDate 】日期转换 【 IRPinYin 】转换成拼音 【 IRTrans 】与十六进制和Ascii转换 IRVerify验证主要包括如下验证： 身份证合法性 手机号的合法性 银行卡号的合法性 数字字符串是否为整数 数字字符串是否为浮点型 金额的合法性【保留两位小数】 UIButtonUIButton： 【 IRImageTitleSpacing 】设置button的titleLabel和imageView的布局样式，及间距 NSDictionary/NSArrayNSDictionary/NSArray： 【 IRLOG 】控制台打印中文 UIColorUIColor： 【 IRExtend 】十六进制的颜色值转为objective-c的颜色 UIViewUIView： 【 IRLayoutMethods 】 UIViewController： 【 IRNavigationBarBackgrounTransparent 】状态栏是否显示背景色 UIImageUIImage： 【 IREx 】去除图片渲染效果 【 IRQRCode 】通过二维码字符串生成可扫描的二维码图片，具体详情 使用通过 Cocoapods 导入 1pod 'IRCategoryCollection' 剩下的只要import相应的头文件就Ok了，相应的category实现都可以看到]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单元测试断言汇总]]></title>
      <url>%2F2017%2F05%2F09%2F17-05-09-unittest-assert%2F</url>
      <content type="text"><![CDATA[本文是对XCTestAssertions.h的简单翻译并添加了自己以及收集的一些想法，如有错误，欢迎指出 XCTFail(…)1XCTFail(@"错误，停止"); 描述文本参数可选相当于在此处放一个bug，让程序停止，提示描述文本任何时候都为 faile XCTAssertNil(expression, …)string = @””，number = 0都是测试失败，只要不是nil都测试失败当表达式等于nil的时候通过，否则测试失败，提示描述文本expression接受 id 类型的参数 XCTAssertNotNil(expression, …)与XCTAssertNil相反，当表达式不等于nil的时候通过，否则测试失败，提示描述文本expression接受 id 类型的参数 XCTAssert(expression, …)当表达式的值为YES的时候通过，否则测试失败，提示描述文本空字符串 = YESnumber = 0 = NO，number != 0 = YESnil = NOexpression接受 BOOL 类型的参数 XCTAssertTrue(expression, …)当表达式的值为YES时通过，否则测试失败，提示描述文本expression接受 BOOL 类型的参数 XCTAssertFalse(expression, …)与XCTAssertFalse相反，当表达式的值为NO时通过，否则测试失败，提示描述文本expression接受 BOOL 类型的参数 XCTAssertEqualObjects(expression1, expression2, …)1XCTAssertEqualObjects(@(3),@(3 - 0),@"表达式1 ！= 表达式2"); 当 表达式1 == 表达式2 时通过， 比较表达式地址 ，否则测试失败，提示描述文本expression接受 id 类型的参数 XCTAssertNotEqualObjects(expression1, expression2, …)与XCTAssertEqualObjects相反，当 表达式1 != 表达式2 时通过，否则测试失败，提示描述文本expression接受 id 类型的参数 XCTAssertEqual(expression1, expression2, …)当 表达式1 == 表达式2 时通过，否则测试失败，提示描述文本expression接受基本类型的参数（数值、结构体之类的）当expression为id类型时，比较两个id类型的地址 XCTAssertNotEqual(expression1, expression2, …)与XCTAssertEqual相反，当 表达式1 != 表达式2 时通过，否则测试失败，提示描述文本expression接受基本类型的参数（数值、结构体之类的）当expression为id类型时，比较两个id类型的地址 XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, …)1XCTAssertEqualWithAccuracy(1,1,0,@"error"); 当 表达式1 - 表达式2 &lt;= accuracy 时通过，否则测试失败，提示描述文本expression，accuracy接受 基础 类型的参数 XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, …)与XCTAssertEqualWithAccuracy相反当 表达式1 - 表达式2 &gt; accuracy 时通过，否则测试失败，提示描述文本expression，accuracy接受 基础 类型的参数 XCTAssertGreaterThan(expression1, expression2, …)1XCTAssertGreaterThan(2, 1, @"error"); 当 表达式1 &gt; 表达式2 时通过，否则测试失败，提示描述文本expression接受 基础 类型的参数 XCTAssertGreaterThanOrEqual(expression1, expression2, …)1XCTAssertGreaterThanOrEqual(2,1,@"error"); 当 表达式1 &gt;= 表达式2 时通过，否则测试失败，提示描述文本expression接受 基础 类型的参数 XCTAssertLessThan(expression1, expression2, …)当 表达式1 &lt; 表达式2 时通过，否则测试失败，提示描述文本expression接受 基础 类型的参数 XCTAssertLessThanOrEqual(expression1, expression2, …)当 表达式1 &lt;= 表达式2 时通过，否则测试失败，提示描述文本expression接受 基础 类型的参数 XCTAssertThrows(expression, …)当表达式抛出异常时通过，否则测试失败，提示描述文本expression为一个表达式 XCTAssertThrowsSpecific(expression, exception_class, …)当表达式没抛指定类exception_class的异常，测试失败。expression为一个表达式exception_class为一个指定类 XCTAssertThrowsSpecificNamed(expression, exception_class, exception_name, …)expression没抛指定类、指定名字的异常，测试失败。expression为一个表达式exception_class为一个指定类exception_name为一个指定名字 XCTAssertNoThrow(expression, …)expression抛出异常时，测试失败。expression为一个表达式 XCTAssertNoThrowSpecific(expression, exception_class, …)expression抛出指定类的异常，测试失败。expression为一个表达式 XCTAssertNoThrowSpecificNamed(expression, exception_class, exception_name, …)expression抛出指定类、指定名字的异常，测试失败。expression为一个表达式exception_class为一个指定类exception_name为一个指定名字 后面的几个说明来自https://my.oschina.net/u/1418722/blog/340194]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NexT]]></title>
      <url>%2F2017%2F04%2F25%2F17-04-25-next%2F</url>
      <content type="text"><![CDATA[NexT在以前一段时间，我一直使用的是 yilia ，个人觉得这个主题还是很实用并且比较符合我的审美的，为什么今天决定换掉他呢？说不定过一段时间我还会换回来哦，换掉他而使用 NexT, 一直以来记录的东西并不是很多，找起来也没那么麻烦，现在东西多了，找起来很费时，因此我需要一个搜索功能。 在 百度 以及 https://hexo.io/themes/ 知乎 GitHub 等网站的搜索查询之下，最后选择了目前在github上有 7.7kstar 的 NexT NexT 也是能比较实用并且符合我的审美标准的，有 http://theme-next.iissnan.com/ 一个专门的网址对NexT进行使用的说明和介绍以及第三方服务的集成方法等。 个人的感觉： yilia 和 NexT 集成与使用相似，都很方便 在功能上我并不知道 yilia 对本地搜索这块是否有准备好样式 NexT 本地搜索可以使用多种第三方服务，样式还不错 整体简单大方 比较悲伤的是以前使用 yilia 时评论使用的是多说，现在使用 NexT 评论系统需要重新配制了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IRMenuPopover]]></title>
      <url>%2F2017%2F04%2F24%2F17-04-24-irmenuPopover%2F</url>
      <content type="text"><![CDATA[原码地址 一个轻量级的menuPop可以通完 *IRMenuPopoverGlobal.h 文件进行弹出框的圆角及其它的基本信息的设置，可以通过storyboard或masonry使用* 效果显示 注意事项 此项目依赖于Masonry，使用cocoapods请在引用此项目文件前导入 pod ‘Masonry’项目文件主要包括： menuPopoverImages.bundle、UIView+LayoutMethods.h、UIView+LayoutMethods.m、IRMenuPopover.h、IRMenuPopover.m、IRMenuPopoverGlobal.h 使用通过此代理方法获取所选中的值 menuPopover:didSelectMenuItemAtIndex: 需实现 IRMenuPopoverDelegate 的两个代理方法 使用方法11234567NSArray * menuSelectOption = @[@"医生",@"警察",@"农民",@"工人"];IRMenuPopover *menuPopver = [[IRMenuPopover alloc] initWithTargetFrame:targetFrame menuItems:menuSelectOption showArrow:YES scrollEnabled:YES];menuPopver.menuPopoverDelegate = self;[self.menuPopver show]; #API介绍 自动适配弹出框显示的位置initWithTargetFrame:menuItems:showArrow:scrollEnabled: 自动对框框进行布局，targetFrame为目标控件的frame 框框自身的size由IRMenuPopoverGlobal.h文件配制 框框在目标控件上显示的位置自动生成 箭头的位置根据所显示的框框的位置自行以适配 1234567891011121314/** 自动对框框进行布局，targetFrame为目标控件的frame 框框自身的size由IRMenuPopoverGlobal.h文件配制 框框在目标控件上显示的位置自动生成 箭头的位置根据所显示的框框的位置自行以适配 @param targetFrame 目标控件的位置 @param aMenuItems 显示的列表项 @param showArrow 是否显示箭头 @param scrollEnabled 内部的列表项是否可以滚动 @return 选择框 */- (id)initWithTargetFrame:(CGRect)targetFrame menuItems:(NSArray *)aMenuItems showArrow:(BOOL)showArrow scrollEnabled:(BOOL)scrollEnabled; 弹出框的位置通过isTop级对弹出框的布局决定initWithFrame:menuItems:showArrow:scrollEnabled:isTop:123456789101112/** 通过外部对框框的布局配合isTop进行生成框框 @param frame 框框要显示的位置 @param aMenuItems 显示的列表项 @param showArrow 是否显示箭头 @param scrollEnabled 内部的列表项是否可以滚动 @param isTop 是否在控件上面显示【需要与外部框框的布局配合使用】 @return 选择框 */- (id)initWithFrame:(CGRect)frame menuItems:(NSArray *)aMenuItems showArrow:(BOOL)showArrow scrollEnabled:(BOOL)scrollEnabled isTop:(BOOL)isTop; ###使用1234567891011121314151617181920212223242526272829#pragma mark - 特别提示，isTop是与menuPopver的上布局配合使用#pragma mark - 特别提示，此处的menuPopver是弹出的框框IRMenuPopover* menuPopver = [[IRMenuPopover alloc] initWithFrame:CGRectMake(self.menuPopoverX, menuPopoverY, MENU_POP_VIEW_WIDTH, MENU_POP_VIEW_HEIGHT) menuItems:self.menuItems showArrow:YES scrollEnabled:YES isTop:NO];self.menuPopver.menuPopoverDelegate = self;[self.menuPopver showInView:[UIApplication sharedApplication].keyWindow];#pragma mark - 特别提示，此处的布局是弹出框框的位置布局/** * 当isTop=YES的时候 */[self.menuPopver mas_makeConstraints:^(MASConstraintMaker *make) &#123;//下 *** 当isTop == NO 的时候，此处必须为这句布局 make.top.equalTo(self.mas_bottom);//上 *** 当isTop == YES的时候，此处必须为这句布局，否则会出现布局乱混// make.bottom.equalTo(self.mas_top);//左 ** 当框框在左面显示的时候// make.left.equalTo(self.mas_left);//右 ** 当框框在右面显示的时候 make.right.equalTo(self.mas_right); make.height.mas_equalTo(MENU_POP_VIEW_HEIGHT); make.width.mas_equalTo(MENU_POP_VIEW_WIDTH);&#125;];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactNativeNode]]></title>
      <url>%2F2017%2F04%2F21%2F17-04-21-reactNative-node-1%2F</url>
      <content type="text"><![CDATA[node1问题描述： 在终端执行如下命令时npm install –save react-redux/npm install –save redux-thunk 报如下错误：UNMET PEER DEPENDENCY redux@^2.0.0 || ^3.0.0 问题解决：这只是缺少依懒模块12npm install --save redux-loggernpm install --save redux-thunk 问题参考链接：http://stackoverflow.com/questions/41505664/getting-error-on-implementing-react-native-with-react-redux node2问题描述：执行 npm install –save redux-logger └── UNMET PEER DEPENDENCY react@^0.13.0 || ^0.14.0 || ^15.0.0 问题解决：版本过底，使用如下信不信1npm install npm -g 问题参考链接：http://stackoverflow.com/questions/32985495/react-router-peerdependencies-error node3问题描述：在通过react-native run-ios运行reactnative运行项目的时候报如下错误 No bundle URL presentMake sure you’re running a packager server or have included a .jsbundle file in your application bundle 问题解决：关掉翻墙软件我是使用shadowocks，将全局代理必成自动代理。我是可以的，如果还是不行关掉shadowocks 问题参考链接：http://www.crifan.com/react_native_ios_run_again_error_no_bundle_url_present/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git使用]]></title>
      <url>%2F2017%2F04%2F21%2F17-04-21-git%2F</url>
      <content type="text"><![CDATA[参考自廖雪峰的官方网站:http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/ 添加文件到本地暂存区: 添加单个文件 1git add hello.md 添加多个文件[用空格区分] 1git add hello.md word.md //此处添加了【hello.md】【word.md】 git commit把暂存区的所有内容提交到当前分支: 回车进入vim输入说明文本，按键盘上[esc]输入:wq 保存退出vim 1git commit 在提交版本的时候以-m为参，输入说明文本 1git commit -m '本次提交的说明文本' git diff file:12git diff file//点击键盘上的[q]退出diff git log显示从最近到最远的提交日志12git log //显示的更为详细git log --pretty=oneline //显示版本号和版本说明 版本回退：HEAD：表示当前版本，当前分支HEAD^：上一个版本HEAD^^：上上一个版本HEAD~100：往上100个版本 1234git reset --hard HEAD^ //回退到上一个版本git reflog //查看git的每一步动作git reset --hard 未来版本idgit reset HEAD file //可以把暂存区的修改撤销掉（unstage），重新放回工作区 git checkout – file丢弃工作区的修改： 一种是文件自修改后还没有git add添加，现在，撤销修改就回到和版本库一模一样的状态； 一种是文件已经git add，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。1git checkout -- &lt;file name&gt; git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 将本地库与远程库关联12345678//要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git//第一次推送master分支的所有内容到远程库git push -u origin master//推送最新修改到远程库git push origin master 直接从远程库克隆1git clone git@server-name:path/repo-name.git 分支创建/切换分支： 创建并切换到新创建的分支下 1git checkout -b &lt;name&gt; 创建分支 1git branch &lt;name&gt; 切换到分支 1git checkout &lt;name&gt; 查看分支git branch命令会列出所有分支，当前分支前面会标一个号* 1git branch 将分支推到远程仓库在要推到远程仓库的分支下1git push --set-upstream origin &lt;name&gt; 合并分支git merge命令用于合并指定分支到当前分支12//dev分支会被合并到当前分支中git merge &lt;branch-name&gt;[要被合并的分支名称] 合并后删除分支1git branch -d &lt;name&gt; 分支没有被合并，如果删除，将丢失掉修改，强行删除1git branch -D &lt;branch-name&gt; 看到分支的合并情况123//查看分支合并图git log --graph git log --graph --pretty=oneline --abbrev-commit 使用Fast forward模式，删除分支后，会丢掉分支信息如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。–no-ff参数，表示禁用Fast forward1git merge --no-ff -m "本次合并要创建一个commit的描述文本" &lt;branch-name&gt; 当工作只进行到一半，还没法提交。但是，必须在现在修复该bug，怎么办？幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：1234567891011121314//转移正在开发的内容到stashgit stash//查看stashgit stash list//将stash中的内容恢复，并将stash内容删除git stash pop//将stash中的内容恢复git stash apply//删除stash中的内容git stash drop 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：1git stash apply stash@&#123;0&#125; 标签创建标签1git tag v1.0[标签名称] 为对应的commit打标签1git tag v0.9 6224937[commit id] 创建带有说明的标签1git tag -a v0.1[标签名称] -m "version 0.1 released 标签说明" 3628164[commit id] 查看标签： 查看标签 1git tag 查看标签信息 1git show &lt;tagname&gt; 删除标签： 删除本地标签 1git tag -d &lt;tag-name&gt; 删除远程标签【1.先将本地标签删除】 1git push origin :refs/tags/tagname 将标签推到远程1234git push origin &lt;tagname&gt;//推送全部尚未推送到远程git push origin --tags git配制1234//显示颜色git config --global color.ui true//别名git config --global alias.st status git fetch：相当于是从远程仓库获取最新版本到本地，不会自动merge，需要程序员自己去merge 12git fetch origin mastergit merge origin/master git pull：从远程仓库获取最新版本，自动merge到本地仓库]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CocoaPods制作与版本更新]]></title>
      <url>%2F2017%2F04%2F21%2F17-04-21-madeCocoaPods%2F</url>
      <content type="text"><![CDATA[IRMakeCocoapodsLibaryTest 这个是我制作的一个Demo，亲们可以先用 Podfile 先看一下，使用一下1pod 'IRMakeCocoapodsLibaryTest' 这是IRMakeCocoapodsLibaryTest在github上的代码 言归正传，开始创建仓库按照如下gif的步骤: 在github上进行项目的创建 将创建好的项目clone到本地 在clone下来的项目中创建一个OC项目 创建项目到本地仓库创建一个项目放到clone到本地的仓库内， 注意：一定要为创建的项目添加Class prefix，不加如果有相同的类名会报错，很麻烦 【图中我只修改了一部分的类前缀，具体按项目文件修改】创建的项目名跟远程项目名相同这一步相对简单，如果有问题可以看下图： 为项目添加 .podspec 文件并进行相关设置1pod spec create IRMakeCocoapodsLibaryTest&lt;根据你的项目名更改&gt; 按如下图片步骤操作： 打开终端，输入 cd 目录 进入到本地仓库 输入 pod spec create IRMakeCocoapodsLibaryTest&lt;此处要改成您自己的项目名&gt; 打开.podspec文件进行相关设置下图是.podspec文件的设置及说明，根据自己的项目进行配制 这是我的本地仓库目录 文件按文件夹区分开管理由于最近另一个公开库的文件较多，所以设置了子文件夹，下面是我另一个公开库的.podspec文件【 大家如果不要看可以直接点击左侧目录跳过 】 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859Pod::Spec.new do |s| ####### 项目名称 s.name = "IRCategoryCollection" ####### 版本号 s.version = "1.0.8" ####### 简短概要 s.summary = "IRCategoryCollection category 管理" ####### 描述【此处的描述字数不宜太少，否则检测的时候会报错，注意查看错误信息】 s.description = &lt;&lt;-DESC 简单便捷的对category进行管理，方便多个项目的使用，避免多个项目使用的复制粘贴问题 DESC ####### 改成你自己的项目首页 s.homepage = "https://github.com/IrenaChou/IRCategoryCollection.git" ####### github中创建项目时选的license s.license = "MIT" ####### 作者 s.author = &#123; "irenaChou" =&gt; "znirena@gmail.com" &#125; ####### 这个是我们在使用Cocoapods时也要用到的版本要求 s.platform = :ios, "8.0" ####### git指向-github上项目的地址 后面tag不要改 s.source = &#123; :git =&gt; "https://github.com/IrenaChou/IRCategoryCollection.git", :tag =&gt; "#&#123;s.version&#125;" &#125; ####### 项目所需要的framework s.framework = "UIKit","Foundation" ####### 是否使用arc s.requires_arc = true ####### 如果文件比较多，不区分成多个文件夹存放，会比较难找 ####### 下面是设置子文件夹，文件夹名称为【NSString】 ####### 下面我是设置了两个子文件夹【NSString】【UIButton】 ####### 设置子文件夹【subspec 后面的字符串是生成的文件夹名称】 s.subspec 'NSString' do |ss| ####### 【我库中的文件都按文件夹区分好了，所以写路径比较整齐】 ####### 这个是AFNetworking里为NSURLSession配制的路径 AFNetworking/AF&#123;URL,HTTP&#125;SessionManager.&#123;h,m&#125; ####### 路径的意思是在 AFNetworking 文件夹下以AF开头，下来是URL或HTTP然后是SessionManager.h或.m的文件 ####### 原文件路径 ss.source_files = 'IRCategoryC/NSString/*.&#123;h,m&#125;' ####### 头文件路径 ss.public_header_files = 'IRCategoryC/NSString/*.h' end s.subspec 'UIButton' do |ss| ss.source_files = 'IRCategoryC/UIButton/*.&#123;h,m&#125;' ss.public_header_files = 'IRCategoryC/UIButton/*.h' endend pod验证及代码提交1pod lib lint 出现如下图的passed validation.就验证通过了， 如果报了问题，仔细看问题描述，根据描述修改 上传到github远程仓库1234567891011121314//添加git add .//提交 -m 后面为描述说明git commit -m 'version 0.0.1'//推到远程仓库git push//打上标签git tag 0.0.1//将标签上传到远程仓库git push --tags 上传{project}.podspec到CocoaPods官方仓库中【搞完这个才是真正的完成】按照git的规则,要想向别人的仓库中添加文件,fork一份,添加修改,然后push给作者,等待审核,然而这条路已经被堵死了..CocoaPods为我们提供了另外一个更方便安全的方法 trunk 注册trunk1pod trunk register *youremail*@gmail.com '*yourname*' --description='iMac' --verbose youremail@gmail.com 换成你自己的，此处我用的是与github相同的emialyourname 换成你的名字 以上命令是注册所需的,替换你的邮箱,用户名,以及描述内容, –verbose可以输入详细的debug 完成后需要到邮箱验证一下才能继续往下做 注册完成后可以使用如下命令查看注册信息1pod trunk me 提交{project}.podspec1pod trunk push IRMakeCocoapodsLibaryTest.podspec 这条命令做了如下三件事: 验证本地的podspec文件,也可以使用 pod lib lint验证 上传podspec文件到trunk服务 将{project}.podspec文件转为{poject}.podspec.json文件 使用1pod search IRMakeCocoapodsLibaryTest 查询后按键盘上的Q键退出 search不到库或是search不到最新版本解决下面是我个人遇到的问题，和解决方法当上面所有的步骤都走的很顺利，没有报错/报错顺利的解决完了，却发现search不到新库 参考自github上的回答 在 terminal 下运行如下命令12345//删除cocoapods的索引rm ~/Library/Caches/CocoaPods/search_index.json//然后重新searchpod search IRMakeCocoapodsLibaryTest 版本更新成功，却seach不到新版本 在 terminal 下运行如下命令12pod repo update --verbosepod search IRMakeCocoapodsLibaryTest 更新版本添加新功能或是修改bug的时候，必然要更新版本的，下面说说版本更新大概步骤如下： 修改或添加项目文件喽 将.podspec文件中的s.version更新成自己对应的版本，如s.version=0.0.5 pod lib lint,验证一下 在将本地仓库提交到远程仓库 123456git add .git commit -m 'version 0.0.5'git pushgit tag 0.0.5&lt;更新的版本&gt;git push --tagspod trunk push IRMakeCocoapodsLibaryTest.podspec 更新完在pod search IRMakeCocoapodsLibaryTest一下就看到版本号更新了，大功告成下图我已经更新过几个版本了，所以版本号是0.0.5 使用 创建一个项目使用一下自己创建好的pods吧 参考：http://www.jianshu.com/p/98407f0c175b]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift-lazy懒加载]]></title>
      <url>%2F2017%2F04%2F21%2F17-01-06-swift-lazy%2F</url>
      <content type="text"><![CDATA[Swift-lazy懒加载1234private lazy var testView : UIView = &#123; let tView = UIView() return tView&#125;()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F21%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift-extension【扩展】]]></title>
      <url>%2F2017%2F01%2F05%2F17-01-05-swift-extension%2F</url>
      <content type="text"><![CDATA[Swift-extension【扩展】扩展能够向已有的类、结构体，枚举或协议类型添加新的功能。这包括在没有权限获取原始代码的情况下扩展类型的能力【即逆向建模】。扩展类似于Objective-C中的分类【categories】，与Objective-C分类不同的是，Swift的extension没有名称，Objective-C中的Category只能扩展类(类别) extension中的private方法不能被已有实现类调用 Swift中的extension可以实现如下的所示的功能： 添加计算型属性和计算静态属性 定义实例方法和类型方法 提供新的构造器器 定义下标 定义和使用新的嵌套类型 使一个已有类型符合某个协议 计算型属性距离转换 1234567891011class IRTestController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let aMarathon = 25.5.mm + 1.2.m print("A marathon is \(aMarathon) meters long") &#125;&#125;extension Double&#123; var m : Double &#123; return self &#125; var mm : Double &#123; return self / 1_000.0 &#125;&#125; 在上述代码中，计算属性的含义是把一个Double型的值看作是某单位下的长度值，实现距离转换 构造器扩展能向类中添加新的便利构造器，不能向类中添加新的指定的构造器或析构造函数。指定构造器和析构造函数必须由原始类实现提供 1234567891011121314class IRTestController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let rect = CGRect(center: CGPoint(x: 4.0,y: 4.0), size: CGSize(width: 3,height: 3)) print(rect) &#125;&#125;extension CGRect &#123; init(center: CGPoint,size: CGSize) &#123; let originX = center.x - size.width * 0.5 let originY = center.y - size.height * 0.5 self.init( origin: CGPoint( x: originX, y: originY ) ,size: size ) &#125;&#125; 扩展方法可以向已有类型添加新的实例方法和类型方法。 扩展增加的实例方法可以修改实例本身。结构体和枚举类型中的方法如果想要修改实例本身或者属性的话需要用mutating来修饰方法，所以扩展这样的方法也需要加mutating。 向Int类型中添加一个名为repetions的新实例方法 1234567891011121314151617181920212223class IRTestController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() var num = 2 num.repetions &#123; print("irena") &#125; num.square() print("\(num) square is \(num)") &#125;&#125;extension Int &#123; /// 参数是一个单类型的闭包，没有参数，没有返回值的闭包 ()-() func repetions(task: () -&gt; ()) &#123; for _ in 1...self &#123; task() &#125; &#125; /// 要修改self，就需要是可改类型方法，需要加上关键字mutating mutating func square() &#123; self = self * self &#125;&#125; 下标扩展可以向一个已有类型添加新下标 如果位数不足返回0 12345678910111213141516171819class IRTestController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() print("\(289435733[3])") //return 5 print("\(2[3])") //return 0 &#125;&#125;extension Int &#123; /// 下标[n]会返回十进制数字从右向左第n个数字 subscript(index: Int) -&gt; Int&#123; var decimalBase = 1 if index &gt; 0 &#123; for _ in 1...index &#123; decimalBase *= 10 &#125; &#125; return (self / decimalBase) % 10 &#125;&#125; 嵌套类型12345678910111213141516171819202122232425262728293031323334class IRTestController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() printIntegerKinds([3, 19, -27, 0, -6, 0, 7]) // return + + - 0 - 0 + &#125; func printIntegerKinds(_ numbers: [Int]) &#123; for number in numbers &#123; switch number.kind &#123; case .negative: print("- ", terminator: "") case .zero: print("0 ", terminator: "") case .positive: print("+ ", terminator: "") &#125; &#125; print("") &#125;&#125;extension Int &#123; enum Kind &#123; case negative, zero, positive &#125; var kind: Kind &#123; switch self &#123; case 0: return .zero case let x where x &gt; 0: return .positive default: return .negative &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS制作framework]]></title>
      <url>%2F2017%2F01%2F04%2F17-01-04-makeFramework%2F</url>
      <content type="text"><![CDATA[生成和使用framework 制作framework本文使用：Xcode Version 8.2.1，macOS Sierra 10.12.2 创建framework文件步骤如下图： ​ 此framework主要有一个打印的测试方法 把真机的framework与模拟器的framework合并【文件本文只生成debug使用的framework】： 使用framework 如上图使用会出现如下错误： 123dyld: Library not loaded: @rpath/IRMakeAPIFramework.framework/IRMakeAPIFramework Referenced from: /var/containers/Bundle/Application/FF92ED2C-8C1B-4CD2-BE8E-583A9DC1B5BC/IRTestAPIFramework.app/IRTestAPIFramework Reason: image not found 解决办法有两个 一是修改生成framework程序后在重新生成framework 另一个生成framework文件使用Dynamic Libary，使用的时候需修改]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[macOS配制SublimeText3运行JavaScript]]></title>
      <url>%2F2016%2F12%2F27%2F16-12-27-macOS-SublimeText3%2F</url>
      <content type="text"><![CDATA[本文使用macOS Sierra 版本 10.12.1 运行javaScript11、下载安装Sublime Text 3 https://download.sublimetext.com/Sublime%20Text%20Build%203126.dmg安装好 键盘command + q 退出Sublime Text 3 12、下载安装nodejs 如果已经存在可以在终端运行如下命令查看node的位置1where node https://nodejs.org/dist/v6.9.2/node-v6.9.2.pkg 安装nodejs时需要注意如下图中红框标的路径【先将其复制保存，如果地址跟我文中的地址相同，可以不用复制，下面直接拷贝我写好的就行】，下面会用到 打开安装好的Sublime Text 3 按如下图片操作 将如下代码复制粘贴 12"cmd": ["/usr/local/bin/node","$file"],"selector":"*.js" ​ 保存起来【名字后面要用到的，起的规范点哦】 点击键盘的command + q，先将Sublime Text 3退出，打开后按如下图操作 输入如下测试代码，保存成.js文件 1console.log('Irena Test') 输入键盘的command + b build一下 安装Package Controlhttps://packagecontrol.io/installation ctrl + ~ ：调出控制台 将如下代码复制到控制台 1import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 当出现如下图红框中的这两个就可以了 选择下图红框所指向的位置 相关插件请参考如下链接 https://packagecontrol.io/browse]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用cocospods遇到的问题]]></title>
      <url>%2F2016%2F12%2F26%2F16-12-26-cocospodsQuestion%2F</url>
      <content type="text"><![CDATA[问题1：[!] Unable to add a source with url https://github.com/CocoaPods/Specs.git named master-1.``You can try adding it manually in ~/.cocoapods/repos or via pod repo add. 问题解决：您电脑上的Xcode大于一个，需自己手动选择一个使用版本，具体做法如下 sudo xcode-select -switch /Applications/Xcode7.3.app【拖拽你要使用的xcode替换/Applications/Xcode7.3.app】 ERROR:Could not find a valid gem &#39;cocoapods&#39; (&gt;= 0), here is why: Unable to download data from https://ruby.taobao.org/ - SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed (https://ruby.taobao.org/specs.4.8.gz) 问题解决：由于淘宝源已停止维护，我们需要更换新源，具体做法如下 查看源：gem sources -l 删除源：gem sources --remove https://ruby.taobao.org/ 添加源：gem sources -a https://gems.ruby-china.org/ 问题2 Generating Pods project Abort trap: 6 问题解决：安装最新发布版本，具体做法如下 sudo gem install cocoapods --pre 问题3： 问题解决：复制红框处的代码，运行 先选择一个存放位置，这里用桌面做一下：cd destkop 运行红框处的代码：git clone https://github.com/CoderMJLee/MJRefresh.git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Launch时隐藏StatusBar]]></title>
      <url>%2F2016%2F11%2F17%2F16-11-17-LaunchHideStatusBar%2F</url>
      <content type="text"><![CDATA[本文使用LaunchScreen.storyboard上添加imageView主要解决在Launch时隐藏StatusBar 在info.plist中添加UIStatusBarHidden]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端切图]]></title>
      <url>%2F2016%2F11%2F17%2F16-11-17-MobileTerminalCutImage%2F</url>
      <content type="text"><![CDATA[本文是对photoshop分层版本导出移动端安卓、iOS版本切图 本文使用硬件：Mac系统：OS X EI Capitan 10.11.5软件：PhotoShop CS6、PxCook v1.4.5beta 操作步骤如下：【具体操作请参考图片】 打开PhotoShop——&gt;点击编辑按钮——&gt;点击远程连接 点击远程连接按钮后，会弹出远程连接的框框，随便输入服务名称和密码【密码长度必须&gt;= 6】，勾选启用远程连接复选勾，点击确定按钮 PhotoShop暂时放下，打下软件PxCook，点击切图工具按钮 默认选中启动远程连接，输入PhotoShop中设置的远程连接密码，点击开始使用按钮 返回PhotoShop，选中图层中要切图的图层，按键盘command或shift，配合鼠标可选择多个图层，同时切多个图片，转换为智能对象需要在单个图层上均操作一次 点击要切图的图层，在选中的图层上单击右键，点击转换为智能对象，将要切图的图层转换为智能对象 PhotoShop准备完毕【不要关掉PhotoShop】，切换到PxCook选择您所需要的相应选项目，选择存放切图的路径，点击切所选图层。大功告成 本文使用软件： PhotoShop PxCook 如果图片链接失效，请在文章下留言，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[App应用内跳转AppStore与iTunesStore]]></title>
      <url>%2F2016%2F11%2F09%2F16-11-09-appJumpAppStore%2F</url>
      <content type="text"><![CDATA[先找到app在itunes.apple.com下的链接【此文的itunes链接是按如下方法找的】 这里以QQ为例：itunes下的链接：https://itunes.apple.com/cn/app/id444934666?mt=8如果要跳转到AppStore，将协议https改成itms-apps：itms-apps://itunes.apple.com/cn/app/id444934666?mt=8如果要跳转到iTunesStore，将协议https改成itms：itms://itunes.apple.com/cn/app/id444934666?mt=8 具体代码如下【以QQ跳转到AppStore为例】：12NSString *url = @"itms://itunes.apple.com/cn/app/id444934666?mt=8";[[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]]; 效果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[生成二维码图片]]></title>
      <url>%2F2016%2F11%2F08%2F16-11-08-qrcodecreate%2F</url>
      <content type="text"><![CDATA[条码样式显示 使用【返回一个image】1[self createQRCodeImageWithQRCode:@"http://irenachou.github.io/"]; 创建【通过二维码字符串生成一个二维码图片】123456789101112131415161718192021222324252627282930313233343536373839404142434445+ (UIImage *)createQRCodeImageWithQRCode:(NSString *)qrcode &#123; // 1.创建滤镜 //filterWithName后name的值，选择不同的值创建不同类型的条码 // CIAztecCodeGenerator //Aztec码是一种类型的二维条码所发明安德鲁朗埃克，小罗伯特·赫西于1995年[1]的代码被发布的AIM，公司在1997年虽然阿兹特克代码的专利，[1]该专利被正式公开领域。[2]阿兹特克代码也发布为ISO / IEC 24778：2008标准。中央取景器图案的相似性的得名阿兹特克金字塔，阿兹特克码具有使用较少的空间比其它的矩阵条形码，因为它不要求一个周边空白“静区”的潜力。 // CIPDF417BarcodeGenerator： //PDF417条码是二维码的一种。PDF417条码是一种高密度、高信息含量的便携式数据文件，是实现证件及卡片等大容量、高可靠性信息自动存储、携带并可用机器自动识读的理想手段 // CICode128BarcodeGenerator：条形码 // CIQRCodeGenerator：二维码 //普通二维码 CIFilter *filter = [CIFilter filterWithName:@"CIQRCodeGenerator"]; // 2.还原滤镜默认属性 [filter setDefaults]; // 3.设置需要生成二维码的数据到滤镜中(OC中要求设置的是一个二进制数据) NSData *data = [qrcode dataUsingEncoding: NSUTF8StringEncoding]; //(这里的字符串就是用来生成二维码的,可直接复制代码只需修改这里如果没有其他需求) [filter setValue:data forKeyPath:@"InputMessage"]; // 4.从滤镜从取出生成好的二维码图片 CIImage *ciImage = [filter outputImage]; return [self createhdUIImageFormCIImage:ciImage size:300];&#125;+ (UIImage *)createhdUIImageFormCIImage:(CIImage *)ciImage size:(CGFloat)size &#123; CGRect wsRect = CGRectIntegral(ciImage.extent); CGFloat scale = MIN(size / CGRectGetWidth(wsRect), size / CGRectGetHeight(wsRect)); // 1.二维码基本设置 // 1.创建bitmap; size_t width = CGRectGetWidth(wsRect) * scale; size_t height = CGRectGetHeight(wsRect) * scale; CGColorSpaceRef cs = CGColorSpaceCreateDeviceGray(); CGContextRef wsRef = CGBitmapContextCreate(nil, width, height, 8, 0, cs, (CGBitmapInfo)kCGImageAlphaNone); CIContext *context = [CIContext contextWithOptions:nil]; CGImageRef wsImageRef = [context createCGImage:ciImage fromRect:wsRect]; CGContextSetInterpolationQuality(wsRef, kCGInterpolationNone); CGContextScaleCTM(wsRef, scale, scale); CGContextDrawImage(wsRef, wsRect, wsImageRef); // 保存bitmap到图片 CGImageRef scaledImage = CGBitmapContextCreateImage(wsRef); CGContextRelease(wsRef); CGImageRelease(wsImageRef); return [UIImage imageWithCGImage:scaledImage];&#125; 通过二维码字符串生成二维码图片的关键代码放在如下链接的category里，需要请下载使用 关键代码下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJS标签]]></title>
      <url>%2F2016%2F10%2F27%2F16-10-27-angularjs%2F</url>
      <content type="text"><![CDATA[通过 script 标签添加到网页中：1&lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt; ng-app指令定义一个 AngularJS 应用程序HTML 文档中只允许有一个ng-app指令，如果有多个 ng-app 指令，则只有第一个会被使用，ng-app 指令用于告诉 AngularJS 应用当前这个元素是根元素。指令在网页加载完毕时会自动引导（自动初始化）应用程序。 ng-model指令ng-model 指令 绑定 HTML 元素 到应用程序数据。把元素值（比如输入域的值）绑定到应用程序。绑定输入框的值到scope变量中，input, select, textarea 标签支持该指令 ng-model 指令也可以： 为应用程序数据提供类型验证（number、email、required）。 为应用程序数据提供状态（invalid、dirty、touched、error）。 为 HTML 元素提供 CSS 类。 绑定 HTML 元素到 HTML 表单。 12345678910&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; 名字: &lt;input ng-model="name" required&gt; &lt;h1&gt;&#123;&#123; name &#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;var app = angular.module('myApp', []);app.controller('myCtrl', function($scope) &#123; $scope.name = "John Doe";&#125;);&lt;/script&gt; ng-bind指令把应用程序数据绑定到 HTML 视图。绑定 标签p 内的 innerHTML 到变量 myText: 具体看如下代码 123&lt;div ng-app="" ng-init="myText='Hello World!'"&gt; &lt;p ng-bind="myText"&gt;&lt;/p&gt;&lt;/div&gt; 属性以 ng- 开头，但是您可以使用 data-ng- 来让网页对 HTML5 有效。表达式写在双大括号内。 123&lt;!-- 直接输出表达式的值 --&gt;eg: &#123;&#123;5+5&#125;&#125;&lt;!-- --&gt; ng-controller指令用于为你的应用添加控制器。在控制器中，你可以编写代码，制作函数和变量，并使用 scope 对象来访问。 12345678910&lt;div ng-app="myApp" ng-controller="myCtrl"&gt; Full Name: &#123;&#123;firstName + " " + lastName&#125;&#125;&lt;/div&gt;&lt;script&gt; var app = angular.module('myApp', []); app.controller('myCtrl', function($scope) &#123; $scope.firstName = "John"; $scope.lastName = "Doe"; &#125;);&lt;/script&gt; ng-init指令ng-init 指令为 AngularJS 应用程序定义了 初始值。通常情况下，不使用 ng-init。您将使用一个控制器或模块来代替它。 ng-repeat指令【循环】re-repeat指令对于集合中(数组中)的每个项目会克隆一次HTML元素 例子如下:1234567891011121314&lt;!-- 循环对象 --&gt;&lt;div ng-app="" ng-init="names=[ &#123;name:'Jani',country:'Norway'&#125;, &#123;name:'Kege',country:'Swden'&#125;, &#123;name:'Kai',country:'Denmark'&#125; ]"&gt; &lt;p&gt;循环对象：&lt;/p&gt; &lt;ul&gt; &lt;li ng-repeat="x in names"&gt; &#123;&#123; x.name + ',' + x.country&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!-- --&gt; 创建自定义的指令1234567891011121314151617&lt;!-- 自定义指令 --&gt;&lt;!-- --&gt;//元素名&lt;runoob-directive&gt;&lt;/runoob-directive&gt;//属性&lt;div runoob-directive&gt;&lt;/div&gt;//类名&lt;div class="runoob-directive"&gt;&lt;/div&gt;//注释&lt;!-- directive: runoob-directive --&gt;&lt;!-- --&gt;&lt;script&gt; var app = angular.module("myApp",[]); app.directive("runoobDirective",function()&#123; return&#123; template : "&lt;h1&gt;自定义指令&lt;/h1&gt;" &#125;; &#125;);&lt;/script&gt; 你可以通过以下方式来调用指令，也可以通过restrict的值限制使用： E作为元素名使用 A作为属性使用 C作为类名使用 M作为注释使用 限制使用1234567var app = angular.module("myApp", []);app.directive("runoobDirective", function() &#123; return &#123; restrict : "A", template : "&lt;h1&gt;自定义指令!&lt;/h1&gt;" &#125;;&#125;); restrict 默认值为 EA, 即可以通过元素名和属性名来调用指令。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义简单倒计时]]></title>
      <url>%2F2016%2F10%2F25%2F16-10-25-countdown%2F</url>
      <content type="text"><![CDATA[效果如下图：如不输入倒计时数字，默认60秒输入倒计时数字后点击键盘的return链确认 关键代码如下【具体代码看Demo】：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 开始倒计时 */- (IBAction)tapped:(id)sender &#123; [sender setEnabled:NO]; self.targetTimeNum.enabled = NO; self.leftNum = [self.currentNum.text integerValue]; self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(tickDown) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];&#125;/** * 更新当前显示的数字 */- (void)tickDown &#123; self.leftNum -= 1; [self.currentNum setText:[NSString stringWithFormat:@"%zd", self.leftNum]]; /** * 放大 */ //创建一个CABasicAnimation对象 CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform.scale"]; self.currentNum.layer.anchorPoint = CGPointMake(.5, .5); animation.fromValue = @0.0f; animation.toValue = @1.0f; //动画时间 animation.duration = 0.5; //是否反转变为原来的属性值 animation.autoreverses = YES; //把animation添加到图层的layer中，便可以播放动画了。forKey指定要应用此动画的属性 [self.currentNum.layer addAnimation:animation forKey:@"scale"]; if (self.leftNum &lt;= 0) &#123; [self systemSound]; [self systemVibrate]; self.targetTimeNum.enabled = YES; [self.starBtn setEnabled:YES]; [self.timer invalidate]; &#125;&#125; 点击Demo下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提示(声音、震动)]]></title>
      <url>%2F2016%2F10%2F20%2F16-10-20-soundVibrate%2F</url>
      <content type="text"><![CDATA[声音提示 导入头文件//#import 1234567#import &lt;Photos/Photos.h&gt;/** * 声音 */- (void)systemSound &#123; AudioServicesPlaySystemSound(SOUNDID);&#125; 振动提示 导入头文件//#import 1234#define SOUNDID 1109 // 1012 -iphone 1152 ipad 1109 ipad- (void)systemVibrate &#123; AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS9http不能正常使用的解决]]></title>
      <url>%2F2016%2F10%2F10%2F16-10-10-iOS9http%2F</url>
      <content type="text"><![CDATA[iOS9引入了新特性App Transport Security (ATS)新特性要求App内访问的网络必须使用HTTPS协议。 解决办法 在Info.plist中添加NSAppTransportSecurity类型Dictionary 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去除图片渲染效果【使tabBarItem及navigation显示原图片】]]></title>
      <url>%2F2016%2F09%2F21%2F16-09-21-imageWithRenderingMode%2F</url>
      <content type="text"><![CDATA[12ctrl.tabBarItem.selectedImage = [[UIImage imageNamed:selImageName] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; 效果如下图： 在为tabBarItem及navigation设置图片的时候会有一层蒙版遮盖，imageWithRenderingMode方法就是为了解决这个问题，去除遮盖显示原图片，遮盖的颜色可以修改self.tabBar.tintColor进行更改 效果如下图：1ctrl.tabBarItem.selectedImage = [UIImage imageNamed:selImageName]; 下面提供一个category，实现如下方法Category下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[oc-synthesize]]></title>
      <url>%2F2016%2F09%2F20%2F16-09-20-synthesize%2F</url>
      <content type="text"><![CDATA[在Xcode4版本之前@property和@synthesize的功能是独立开来的： .h中的代码 1234//@property的作用是：自动的生成成员变量setter/getter方法的声明： @property int carName; //它的作用和下面两行代码的作用相同 - (void)setCarName:(int)carName; - (int)carName; 注意：属性名称不要加前缀_ 否则生成的setter/getter方法中也会有下划线 .m中的代码123//@synthesize的作用是实现@property定义的方法代码如：@synthesize carName//将@propertys中定义的属性自动生成setter/getter的实现方法而且默认访问成员变量carName 123如果指定访问成员变量_carName：@synthesize carName = _carName；就是说 实现@property中声明的carName成员变量生成setter/getter方法，并且在实现方法内部访问_carName这个成员变量，也就意味着给成员 _carName 赋值 如果在.h文件中没有定义_carName成员变量的话，就会在.m文件中自动生成@private类型的成员变量_carName 在Xcode4以后@property会实现以上所有功能,可以不用在.m文件中写@synthesize]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[通过slider调整图片的大小]]></title>
      <url>%2F2016%2F09%2F12%2F16-09-12-sliderConvertPhotoSize%2F</url>
      <content type="text"><![CDATA[Demo下载 关键代码123456789101112131415- (void)sliderAction:(UISlider *)sender &#123; sender.value += 0.01; CGFloat mumValue = 0.01; _currentImage.transform = self.upValue &gt; sender.value ? CGAffineTransformMakeScale(sender.value - mumValue, sender.value - mumValue) : _currentImage.transform; _currentImage.transform = self.upValue &lt; sender.value ? _currentImage.transform = CGAffineTransformMakeScale( sender.value + mumValue, sender.value + mumValue) : _currentImage.transform; self.upValue = sender.value;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift基本语法2]]></title>
      <url>%2F2016%2F08%2F25%2F16-08-25-Swift-basic2%2F</url>
      <content type="text"><![CDATA[Swift中如果使用十进制表示指数，需使用e/E表示幂e2表示10^2 12let num = 2e2 //输出打印num = 200.0let num1 = 2e-2 //输出打印num = 0.2 用十六进制表示指数，需用p/P表示幂，p2表示2^212let num = 0xAp2 // 40.0let num1 = 0xAp-2 //2.5 Swift中数字比较大的整数可以用‘_’分割，其实际意义不变1let num = 2_234_500 //2234500 将整数、浮点数等其它数据类型与字符串拼接可用’()’12let num = 3let total = "\(num) 加 10 等于 \(num + 10)" switch条件表达式可以使用整数、浮点数、字符、字符串和元组等类型， case分支不需要显示地添加break语句，分支执行完成就会跳出case case可以是闭区间’…’和半闭区间’..’运算符 元组switch1234567891011var student = (id:"1001",name:"李四",age:32) switch student &#123;case (_,_,let age) where age &gt;= 32: //case中使用where语句，进行条件过滤，类似SQL中的where if (age&gt;30) &#123; print("a") &#125;else&#123; print("b") &#125;default: print("")&#125; 跳转语句continue同break使用相似，也可选择是否使用标签break可选择是否带标签，如break,break label默认情况下break只会跳出最近的内循环，带标签break会直接跳出指定标签的循环12345678abc: for _ in 0 ..&lt; 10 &#123; for i in 0 ..&lt; 10 &#123; print(i) if i == 3 &#123; break abc &#125; &#125;&#125; fallthrough：是贯通语句，只能使用在switch语句中。switch中的case默认不支持贯通，只有case中添加fallthrough的才可以贯通12345678910var j = 1switch j &#123;case 1: j += 1 print("1") fallthroughdefault: j += 1 print("4")&#125; 数组：有序，可重复，不可变数组在访问效率上比可变数组高12345678var studentList1 : Array&lt;String&gt; //&lt;String&gt;此数组是一个泛型数组，其中只能放字符串studentList1 = ["aa","bb"] //初始化数组studentList1 += ["abc","aab"] //数组可以使用+=添加数组studentList1.append("cc") //想数组中添加单个元素，元素添加到数组最后一个元素的后面//移除数组中的元素studentList1.removeLast()studentList1.insert("a0", atIndex: 0) //添加元素到制定下标studentList1.removeAtIndex(1) //移除指定下标的元素 字典：键不要重复，值可重复，键值无序，Swift中的集合都是结构体类型12345let studentDictionary : Dictionary&lt;Int,String&gt; = [101:"aa",102:"bb"]//遍历for (stuId ,stuName) in studentDictionary &#123; print("stuId: \(stuId) == stuName:\(stuName)")&#125; 函数的定义语法，函数可以重载 //Swift中函数的返回值是用这种格式来的1234567891011private func testFunc()-&gt;CGPathRef&#123; //函数体，函数的具体实现 return xx.CGPath&#125;private : 函数的作用域func : 函数的修饰符testFunc: 函数名() : 函数名后的这对小括号中间的为函数的参数列表【多个参数用'**,**'分割】//如果没有返回值，下面两个省略-&gt;CGPathRef： 函数的返回值类型【返回值可以是单个或多个，多个用元组】return ： 函数的返回值，类型要和返回值类型一致 函数的嵌套和函数作为返回值12345678func calculate(opr:String) -&gt; (Int,Int)-&gt;Int &#123; func add(a:Int,b:Int)-&gt;Int&#123; return a+b &#125; var result : (Int,Int)-&gt;Int result = add return result&#125; 闭包：12345var result : (Int,Int)-&gt;Int result = &#123;$0 + $1&#125; result = &#123;(a:Int, b:Int)-&gt;Int in return a + b &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[加减控件IRPlusLessSwift]]></title>
      <url>%2F2016%2F08%2F24%2F16-08-24-IRPlusLessSwift%2F</url>
      <content type="text"><![CDATA[Demo下载 效果展示 使用代码1234567891011import UIKitclass ViewController: UIViewController &#123; /// 定义属性 var plusLessView : IRPlusLessView? override func viewDidLoad() &#123; super.viewDidLoad() plusLessView = IRPlusLessView(frame: CGRect(x: 100,y: 100,width: 200,height: 50)) plusLessView!.maxNum = 3 plusLessView!.styleColor = UIColor.greenColor() self.view.addSubview(plusLessView!) &#125; 具体代码请下载Demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift基础1]]></title>
      <url>%2F2016%2F08%2F23%2F16-08-23-swift-basic-1%2F</url>
      <content type="text"><![CDATA[Swift中取余运算符可用于浮点型Swift3 取消了’++’，’–’ 第一个问题：Property &apos;self.test&apos; not initialized at super.init call 解答：Swift中定义的属性必须要满足以下两者之一，如果没有满足以下二者之一，就会报如下错误 一：可以为空 ** 1private var test : Int? 二：有初使值 1internal var test : Int = 5 第二个问题：为UIButton添加点击事件时，func转selector问题 解答：12345678910let testBtn = UIButton.init()testBtn.addTarget(self, action:#selector(ViewController.test(_:)), forControlEvents: UIControlEvents.TouchUpInside)/**按钮点击调用函数- parameter sender: 被点击的按钮 */@objcprivate func test(sender:UIButton) &#123; print("aaa")&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[加减控件IRPlusLessView]]></title>
      <url>%2F2016%2F08%2F19%2F16-08-19-plusLessView%2F</url>
      <content type="text"><![CDATA[Demo下载 效果展示 使用代码1234567#import "IRPlusLessView.h" IRPlusLessView *plusLessView = [[IRPlusLessView alloc] initWithFrame:CGRectMake(100, 100, 150, 50)]; _plusLessView = plusLessView; plusLessView.maxNum = 3; // plusLessView.colorStyle = [UIColor greenColor]; [self.view addSubview:plusLessView]; 具体代码请下载Demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[身份证号合法性验证]]></title>
      <url>%2F2016%2F08%2F18%2F16-08-18-idcardVer%2F</url>
      <content type="text"><![CDATA[此方法主要验证身份证号的合法性 方法定义1234567891011#import &lt;Foundation/Foundation.h&gt;@interface NSString (Extension)/** * 身份证识别 * * @param cardNo 身份证号 * * @return 是否正确 */+ (BOOL)checkIdentityCardNo:(NSString *)cardNo;@end 方法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#import "NSString+Extension.h"@implementation NSString (Extension)#pragma mark - 身份证识别/** * 身份证合法性验证 * * @param cardNo 身份证号 * * @return 是否合法【1-合法，0-不合法】 */+ (BOOL)checkIdentityCardNo:(NSString *)cardNo &#123; if (cardNo.length != 18) &#123; return NO; &#125; NSArray *codeArray = [NSArray arrayWithObjects:@"7", @"9", @"10", @"5", @"8", @"4", @"2", @"1", @"6", @"3", @"7", @"9", @"10", @"5", @"8", @"4", @"2", nil]; NSDictionary *checkCodeDic = [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects:@"1", @"0", @"X", @"9", @"8", @"7", @"6", @"5", @"4", @"3", @"2", nil] forKeys:[NSArray arrayWithObjects:@"0", @"1", @"2", @"3", @"4", @"5", @"6", @"7", @"8", @"9", @"10", nil]]; NSScanner *scan = [NSScanner scannerWithString:[cardNo substringToIndex:17]]; int val; BOOL isNum = [scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd]; if (!isNum) &#123; return NO; &#125; int sumValue = 0; for (int i = 0; i &lt; 17; i++) &#123; sumValue += [[cardNo substringWithRange:NSMakeRange(i, 1)] intValue] * [[codeArray objectAtIndex:i] intValue]; &#125; NSString *strlast = [checkCodeDic objectForKey:[NSString stringWithFormat:@"%d", sumValue % 11]]; if ([strlast isEqualToString:[[cardNo substringWithRange:NSMakeRange(17, 1)] uppercaseString]]) &#123; return YES; &#125; return NO;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bundle中常用]]></title>
      <url>%2F2016%2F08%2F08%2F16-08-08-bundle%2F</url>
      <content type="text"><![CDATA[123456789101112UUID: [[UIDevice currentDevice] identifierForVendor]Bundle identifier: NSDictionary *dic = [[NSBundle mainBundle] infoDictionary]; //获取info－plistCFBundleName NSString *appIdentifier = [dic objectForKey:@"CFBundleIdentifier"]; //获取Bundle identifierApp Name: NSString *appName = [dic objectForKey:@"CFBundleName"]; //获取Bundle nameBundle Version: NSString *appVersion = [dic valueForKey:@"CFBundleVersion"]; //获取Bundle Version]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS自定义Present转场动画]]></title>
      <url>%2F2016%2F08%2F04%2F16-08-04-presentTransiton%2F</url>
      <content type="text"><![CDATA[每一个界面切换到另一个界面，都是不同场景之前的转换,场景的转换用的就是转场动画自定义转场： 设置自定义转场playerVC.modalPresentationStyle = UIModalPresentationCustom; 1234567 /** 系统转场效果 * 当从A场景过度到B场景，A场景消失，B场景会加到一个容器View中(UITransitionView) */// （设置系统自带转场）修改转场动画的动画效果playerVC.modalTransitionStyle = UIModalTransitionStyleFlipHorizontal; 1234567 /** * 自定义转场效果 * 当从A场景过度到B场景，A场景不消失，B场景会加到一个容器View中(UITransitionView) * 如果设置了自定义转场，未实现转场效果，还会使用系统默认的转场动画 */// 设置自定义转场动画playerVC.modalPresentationStyle = UIModalPresentationCustom; 通过代理设置如何进行自定义转场playerVC.transitioningDelegate = self; [self presentViewController:playerVC animated:YES completion:nil]; 实现代理方法&lt;UIViewControllerTransitioningDelegate&gt;的代理方法，代码中会详细说明 UIViewControllerTransitioningDelegate12345678910111213141516171819202122232425262728293031/** * 弹出时执行的动画 * 当A控制器转场到B控制器时，弹出 * @param presented A控制器 * @param presenting B控制器 * * @return 当view呈现的时候，要通过哪个对象来执行方法 */- (nullable id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source &#123; // 返回一个对象 IRAnimationPresentedProxy *presentedProxy = [[IRAnimationPresentedProxy alloc] init]; return presentedProxy;&#125;/** * 消失时执行的动画 * 当B控制器消失时，消失 * @param dismissed B控制器 * * @return 控制器在dismiss时，要通过哪个对象来执行转场动画 */- (nullable id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed &#123; // 返回一个对象 IRAnimationDismissedProxy *dismissedProxy = [[IRAnimationDismissedProxy alloc] init]; return dismissedProxy;&#125; 其他代码在Demo中提现，需要注意如下几点： B控制器旋转出来时anchorPoint必须在设置frame之前设置 当转场动画方法执行完之后，必须调用此方法[transitionContext completeTransition:YES];，否则B控制器将无法监听任何事件 其他具体代码看Demo Demo下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[anchorPoint锚点]]></title>
      <url>%2F2016%2F07%2F28%2F16-07-28-anchorPoint%2F</url>
      <content type="text"><![CDATA[anchorpoint（锚点）默认值是(0.5,0.5) 与CGAffineTransform连用，通过anchorpoint改变旋转点 view.layer.anchorPoint = CGPointMake(0.5, 1); anchorPoint必须在frame前设置，否则会影响frame的位置而来，【frame是根据center,anchorPoint,bounds等值计算而来】 通过查看API发现,在像CGAffineTransformRotate，CGAffineTransform..的函数最后都会调用CGAffineTransform函数； 通过如下方法，我们使用CGAffineTransform函数实现一个旋转 12345678910/** * 通过CGAffineTransform api算旋转45度 */ CGFloat radians = M_PI_4; CGFloat a = cosf(radians); CGFloat b = sinf(radians); CGFloat c = -cosf(radians); CGFloat d = cosf(radians); // 旋转45度 self.blueView.transform = CGAffineTransformMake(a, b, c, d, 0, 0);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 9+ 通讯录 Contacts Framework]]></title>
      <url>%2F2016%2F07%2F27%2F16-07-27-contactsFramework%2F</url>
      <content type="text"><![CDATA[iOS9的联系人相关框架 Contacts FrameworkiOS 9.0介绍了Contacts和Contacts UI frameworks（ Contacts.framework和ContactsUI.framework ） ，这对于通讯簿提供现代化的面向对象的替换和Address Book UI frameworks.这个框架是线程安全的 要了解更多信息. CNContactStore:是线程安全的类，它可以读取并保存联系人，组和容器。它代表了用户的联系人数据库。它封装了所有的I / O操作和负责获取和联系人和群组的保存。由于联系人存储方法是同步的，所以建议您使用他们在后台线程。 CNSaveRequest：该类定义了一个保存请求操作联系人。该类存储每个操作的请求。可以批量多次更改到一个保存请求（注意，这些更改仅适用于对象）。在重叠的多个并发或保存请求变更的情况下，最后的改变获胜。如果您尝试添加一个对象（即，联系人或组，）已经存在于CNContactStore，CNErrorCodeInsertedRecordAlreadyExists出现错误和CNErrorUserInfoAffectedRecordsKey阵列更新为包含您试图添加的对象。如果您尝试更新或删除对象，它是不存在的联系人存储，保存请求不执行更新或删除，则CNErrorCodeRecordDoesNotExist发生错误，CNErrorUserInfoAffectedRecordsKey阵列更新为包含您尝试更新或删除对象。而保存请求正在执行，不能存取保存请求对象。 CNContactPickerDelegateCNContactPickerDelegate提供了单次选择单个联系人和多个联系人的方法，实现了单次选择多个联系人的方法，选择单个联系人的方法就会失效 需要注意的：1234567891011 /*** 此处需要注意的是*- (void)deleteContact:(CNMutableContact *)contact;*方法需要的是CNMutableContact，如果传CNContact会报如下错误*-[CNContact setSnapshot:]: unrecognized selector sent to instance*0x1488be1a0* 解决错误的方法就是使用CNMutableContact[saveRequest deleteContact:self.contact]; //错误的解决方法如下*/[saveRequest deleteContact:[self.contact mutableCopy]]; Demo提供Demo提供 下面提供一个添加联系人的代码，如需其它方法的使用，请看Demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//创建一个可变对象添加到联系人 CNMutableContact *contact = [[CNMutableContact alloc] init]; //将资料图片作为NSData对象 // contact.imageData = [NSData data]; //设置名字 contact.givenName = @"John"; //设置姓氏 contact.familyName = @"Appleseed"; CNLabeledValue *homeEmail = [CNLabeledValue labeledValueWithLabel:CNLabelHome value:@"john@example.com"]; CNLabeledValue *workEmail = [CNLabeledValue labeledValueWithLabel:CNLabelWork value:@"j.appleseed@icloud.com"]; contact.emailAddresses = @[ homeEmail, workEmail ]; // /** * 设置电话号码 */ contact.phoneNumbers = @[ [CNLabeledValue labeledValueWithLabel:CNLabelPhoneNumberiPhone value:[CNPhoneNumber phoneNumberWithStringValue: @"(408) 555-0126"]] ]; /** 设置地址 */ CNMutablePostalAddress *homeAdress = [[CNMutablePostalAddress alloc] init]; //街道 homeAdress.street = @"1 Infinite Loop"; //城市 homeAdress.city = @"Cupertino"; //国家代码 homeAdress.state = @"CA"; //邮编 homeAdress.postalCode = @"95014"; contact.postalAddresses = @[ [CNLabeledValue labeledValueWithLabel:CNLabelHome value:homeAdress] ]; /** 设置生日 */ NSDateComponents *birthday = [[NSDateComponents alloc] init]; birthday.day = 1; birthday.month = 4; birthday.year = 1988; contact.birthday = birthday; //初始化方法 CNSaveRequest *saveRequest = [[CNSaveRequest alloc] init]; //保存新创建的contact [saveRequest addContact:contact toContainerWithIdentifier:nil]; //更新用户的联系人数据库 CNContactStore *store = [[CNContactStore alloc] init]; [store executeSaveRequest:saveRequest error:nil];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrollView添加子控件向下偏移automaticallyAdjustsScrollViewInsets]]></title>
      <url>%2F2016%2F07%2F05%2F16-07-05-automaticallyAdjustsScrollViewInsets%2F</url>
      <content type="text"><![CDATA[self.automaticallyAdjustsScrollViewInsets = NO;此属性默认为YES，UIViewController下如果只有一个UIScollView或者其子类，那么会自动留出空白，让scollview滚动不会被各种bar盖住。但是每个UIViewController只能有唯一一个UIScollView或者其子类，如果超过一个，需要将此属性设置为NO,自己去控制留白以及坐标问题。 我将scrollView的坐标避开各种bar，就会看到automaticallyAdjustsScrollViewInsets属性的效果通过如上两张图片已经很能说明automaticallyAdjustsScrollViewInsets = YES时的效果了 如果将scrollView的frame设置和屏幕大小相同，就不会出现我模拟的问题解决如上留白效果： 将scrollView的frame设置与主屏幕frame相同 将self.automaticallyAdjustsScrollViewInsets = YES; 关键代码1.代码如下1234#define kScreenWidth [UIScreen mainScreen].bounds.size.width#define kScreenHeight [UIScreen mainScreen].bounds.size.height UIScrollView *scrollHomeView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, kScreenWidth, kScreenHeight)]; 2.代码如下12self.edgesForExtendedLayout = UIRectEdgeNone;self.automaticallyAdjustsScrollViewInsets = YES ; // 其中的self是控制器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为navigationBar添加阴影]]></title>
      <url>%2F2016%2F07%2F05%2F16-07-05-navigationBarShadow%2F</url>
      <content type="text"><![CDATA[效果 代码1234self.navigationController.navigationBar.layer.shadowColor = [UIColor blackColor].CGColor; //shadowColor阴影颜色self.navigationController.navigationBar.layer.shadowOffset = CGSizeMake(2.0f, 2.0f); // shadowOffset阴影偏移x，y向(上/下)偏移(-/+)2self.navigationController.navigationBar.layer.shadowOpacity = 0.3f; //阴影透明度，默认0self.navigationController.navigationBar.layer.shadowRadius = 4.0f; //阴影半径]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git 用户名配制]]></title>
      <url>%2F2016%2F06%2F24%2F16-06-24-gitConfigUser%2F</url>
      <content type="text"><![CDATA[设置单个仓库用户名和邮箱12$ git config user.name "xxx@xxx.com"$ git config user.email "xxx@xxx.com" 设置全局用户名和邮箱12$ git config --global user.email "xxx@gmail.com"$ git config --global user.name "xxx" 写这篇文章主要是为了记录前两天遇到的问题，当时博客是放在github上的，使用的用户名和邮箱与公司仓库的用户名与邮箱不同，使我陷入了申请SSH公钥的困惑中（我测试的结果是最终有效的SSH公钥只能是最后申请的SSH，导致我不能同时使用博客和公司代码仓库）。 我的解决办法：我博客使用SSH，配置这个仓库的用户名和邮箱（不使用全局用户名，邮箱）公司仓库使用HTTP协议，无需申请SSH公钥，使用全局用户名和邮箱，或是单独配置都可以]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UICollectionView处理翻半页问题]]></title>
      <url>%2F2016%2F06%2F24%2F16-06-24-collectionViewCell%2F</url>
      <content type="text"><![CDATA[大部分使用过collectionView的朋友，一定会有遇到过如下问题的，想实现图1的效果，结果确如图2（我称这种效果为翻半页）： 图1 图2 本文实现的思路：如cell个数不能正好填充满一整页，填充空cell，使用cell填充满一整页，避开翻半页的效果，需要注意的是返回cell个数是添加了空cell后的总个数 计算总cell代码如下12345678910/** * 计算包含空cell的总cell数 */- (NSUInteger)pageSumCount &#123; _pageSumCount = [self.items count]; while (_pageSumCount % kPageCellCount != 0) &#123; ++_pageSumCount; &#125; return _pageSumCount;&#125; Demo下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS AES(ECB + PKCS5Padding)]]></title>
      <url>%2F2016%2F06%2F23%2F16-06-23-AES%2F</url>
      <content type="text"><![CDATA[AES（高级加密标准）高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 AES又分多种加密格式和填充方式，如果加解密端采用不同的加密格式或填充方式，即使都是采用AES算法，同样无法解密成功。 下面推荐一个在线加密的网址，支持多种加密格式及填充方式的选择：在线加解密网址 加密格式：ECB, CBC, CTR, OFB, CFBECB方式不需要初始化向量。如果不是采用ECB，那么除了密钥之外，加解密放的初始化向量也必须一致。 填充方式：pkcs5padding, pkcs7padding(PKCS7Padding和PKCS5Padding是兼容的), zeropadding, iso10126, ansix923 如下代码主要针对ECB和pkcs5padding：1234567891011121314151617181920#import &lt;CommonCrypto/CommonCryptor.h&gt;#import &lt;CommonCrypto/CommonDigest.h&gt;#import "NSData+CommonCrypto.h"#import "NSData+ZDAES256.h"@implementation NSData (ZDAES256)- (NSData *)encryptText:(NSString *)text key:(NSString *)key &#123; CCCryptorStatus status = kCCSuccess; NSData *result = [[text dataUsingEncoding:NSUTF8StringEncoding] dataEncryptedUsingAlgorithm:kCCAlgorithmAES128 key:key initializationVector:nil // ECB加密不会用到iv options:(kCCOptionPKCS7Padding | kCCOptionECBMode) error:&amp;status]; if (status != kCCSuccess) &#123; NSLog(@"加密失败:%d", status); return nil; &#125; return result;&#125;@end Demo下载参考原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Button文字(titleLabel)与图片排列(imageView)及间距]]></title>
      <url>%2F2016%2F06%2F20%2F16-06-20-button%2F</url>
      <content type="text"><![CDATA[使用Button自带的titleLabel和imageView，用来设置label和image的排列方式 titleEdgeInsets是titleLabel相对于其上下左右的inset，跟tableView的contentInset是类似的； 如果只有title，那titleLabel的 上下左右 都是 相对于Button 的； 如果只有image，那imageView的 上下左右 都是 相对于Button 的； 如果同时有image和label，那image的 上下左 是 相对于Button 的，右 是 相对于label 的；label的 上下右 是 相对于Button的， 左 是 相对于label 的。 .h文件代码定义 12345678910111213141516#import &lt;UIKit/UIKit.h&gt;typedef NS_ENUM(NSUInteger, MKButtonEdgeInsetsStyle) &#123; MKButtonEdgeInsetsStyleTop, // image在上，label在下 MKButtonEdgeInsetsStyleLeft, // image在左，label在右 MKButtonEdgeInsetsStyleBottom, // image在下，label在上 MKButtonEdgeInsetsStyleRight // image在右，label在左&#125;;@interface UIButton (ImageTitleSpacing)/** * 设置button的titleLabel和imageView的布局样式，及间距 * * @param style titleLabel和imageView的布局样式 * @param space titleLabel和imageView的间距 */- (void)layoutButtonWithEdgeInsetsStyle:(MKButtonEdgeInsetsStyle)style imageTitleSpace:(CGFloat)space; .m实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#import "UIButton+ImageTitleSpacing.h"@implementation UIButton (ImageTitleSpacing)- (void)layoutButtonWithEdgeInsetsStyle:(MKButtonEdgeInsetsStyle)style imageTitleSpace:(CGFloat)space&#123; // 1. 得到imageView和titleLabel的宽、高 CGFloat imageWith = self.imageView.frame.size.width; CGFloat imageHeight = self.imageView.frame.size.height; CGFloat labelWidth = 0.0; CGFloat labelHeight = 0.0; if ([UIDevice currentDevice].systemVersion.floatValue &gt;= 8.0) &#123; // 由于iOS8中titleLabel的size为0，用下面的这种设置 labelWidth = self.titleLabel.intrinsicContentSize.width; labelHeight = self.titleLabel.intrinsicContentSize.height; &#125; else &#123; labelWidth = self.titleLabel.frame.size.width; labelHeight = self.titleLabel.frame.size.height; &#125; // 2. 声明全局的imageEdgeInsets和labelEdgeInsets UIEdgeInsets imageEdgeInsets = UIEdgeInsetsZero; UIEdgeInsets labelEdgeInsets = UIEdgeInsetsZero; // 3. 根据style和space得到imageEdgeInsets和labelEdgeInsets的值 switch (style) &#123; case MKButtonEdgeInsetsStyleTop: &#123; imageEdgeInsets = UIEdgeInsetsMake(-labelHeight-space/2.0, 0, 0, -labelWidth); labelEdgeInsets = UIEdgeInsetsMake(0, -imageWith, -imageHeight-space/2.0, 0); &#125; break; case MKButtonEdgeInsetsStyleLeft: &#123; imageEdgeInsets = UIEdgeInsetsMake(0, -space/2.0, 0, space/2.0); labelEdgeInsets = UIEdgeInsetsMake(0, space/2.0, 0, -space/2.0); &#125; break; case MKButtonEdgeInsetsStyleBottom: &#123; imageEdgeInsets = UIEdgeInsetsMake(0, 0, -labelHeight-space/2.0, -labelWidth); labelEdgeInsets = UIEdgeInsetsMake(-imageHeight-space/2.0, -imageWith, 0, 0); &#125; break; case MKButtonEdgeInsetsStyleRight: &#123; imageEdgeInsets = UIEdgeInsetsMake(0, labelWidth+space/2.0, 0, -labelWidth-space/2.0); labelEdgeInsets = UIEdgeInsetsMake(0, -imageWith-space/2.0, 0, imageWith+space/2.0); &#125; break; default: break; &#125; // 4. 赋值 self.titleEdgeInsets = labelEdgeInsets; self.imageEdgeInsets = imageEdgeInsets;&#125; Demo下载 参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查找离自己最近的vc]]></title>
      <url>%2F2016%2F06%2F15%2F16-06-15-viewControllerFind%2F</url>
      <content type="text"><![CDATA[1234567891011121314/** * 查找离自己最近的一个父类vc(viewController) * * @return 找到的vc */- (UIViewController *)viewController &#123; for (UIView *next = self.view.superview; next; next = next.superview) &#123; UIResponder *nextResponder = [next nextResponder]; if ([nextResponder isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)nextResponder; &#125; &#125; return nil;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIView Clip Subviews]]></title>
      <url>%2F2016%2F06%2F14%2F16-06-14-ViewClipSubviews%2F</url>
      <content type="text"><![CDATA[最终效果 用代码实现如下1[self.baseView setClipsToBounds:YES]; 用storyBoard或xib操作步骤： 为父类勾选如下图红框中的选项 未勾选的效果如下 Demo下载本文使用iOS9.3 Xcode7.3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UIMenuController UITextField 的功能(复制，剪切...)菜单]]></title>
      <url>%2F2016%2F06%2F13%2F16-06-13-UIMenuController%2F</url>
      <content type="text"><![CDATA[参考原文苹果自带的UIMenuController功能扩展 下面实现的效果如下图 下面代码是自定义UITextField类的.m文件，.h中为空，如用Category会影响到全文12345678910111213141516171819202122232425#import "menuController.h"@implementation menuController- (BOOL)canPerformAction:(SEL)action withSender:(id)sender &#123; UIMenuController *menuController = [UIMenuController sharedMenuController]; UIMenuItem *item1 = [[UIMenuItem alloc] initWithTitle:@"你好" action:@selector(abc)]; menuController.menuItems = @[ item1 ]; NSLog(@"%@", NSStringFromSelector(action)); if (action == @selector(cut:) || action == @selector(copy:) || action == @selector(paste:) || action == @selector(abc) || action == @selector(select:)) &#123; return YES; &#125; return NO;&#125;- (void)cut:(nullable id)sender &#123; NSLog(@"%s", __func__);&#125;/** * UIMenuItem 点击 */- (void)abc &#123; self.text = [NSString stringWithFormat:@"%@你好", self.text];&#125;@end 一、UIMenuController认识 默认情况下，UITextView / UITextFiled / UIWebView 都有苹果自带的有UIMenuController功能 UITextFiled 的弹出菜单效果是系统自带的 二、UIMenuController基本使用 如为指定控件添加该功能；我们可以自定义； 通过sharedMenuController获取单例对象； 必须手动设置弹窗菜单可见； 指定弹窗相对哪个View的哪个位置显示; 指定其显示方向（上下左右）； 指定Item多个（数组）； 而且可以指定menuFrame；不仅如此，系统也提供了可以监听menu的通知（即将显示/完全显示、即将隐藏/完全隐藏、menu的frame改变） 具体实现如下： 获得菜单 menu UIMenuController *menu = [UIMenuController sharedMenuController]; 设置菜单最终显示的位置 123456 // 菜单最终显示的位置CGRect rect = CGRectMake(100, 100, 100, 100);[menu setTargetRect:rect inView:self.label];//// targetRect：menuController指向的矩形框//targetView：targetRect以targetView的左上角为坐标原点 手动设置需要，显示菜单 [menu setMenuVisible:YES animated:YES]; 必须要得通过第一响应者，来告诉MenuController它内部应该显示什么内容a. 让第一响应者，实现下面方法，来告诉显示内容，监听哪些操作action 1234567891011121314151617181920212223242526272829303132/*** 通过这个方法告诉UIMenuController它内部应该显示什么内容* 返回YES，就代表支持action这个操作*/- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; NSLog(@"%@", NSStringFromSelector(action)); if (action == @selector(cut:) || action == @selector(copy:) || action == @selector(paste:)) &#123; return YES; // YES -&gt; 代表我们只监听 cut: / copy: / paste:方法 &#125; return NO; // 除了上面的操作，都不支持&#125;// 打印如下：2015-7-28 10:06:25.578 UIMenuController[4735:388013] cut:2015-7-28 10:06:25.581 UIMenuController[4735:388013] copy:2015-7-28 10:06:25.581 UIMenuController[4735:388013] select:2015-7-28 10:06:25.582 UIMenuController[4735:388013] selectAll:2015-7-28 10:06:25.582 UIMenuController[4735:388013] paste:2015-7-28 10:06:25.582 UIMenuController[4735:388013] delete:2015-7-28 10:06:25.582 UIMenuController[4735:388013] _promptForReplace:2015-7-28 10:06:25.583 UIMenuController[4735:388013] _transliterateChinese:2015-7-28 10:06:25.583 UIMenuController[4735:388013] _showTextStyleOptions:2015-7-28 10:06:25.583 UIMenuController[4735:388013] _define:2015-7-28 10:06:25.583 UIMenuController[4735:388013] _addShortcut:2015-7-28 10:06:25.583 UIMenuController[4735:388013] _accessibilitySpeak:2015-7-28 10:06:25.583 UIMenuController[4735:388013] _accessibilitySpeakLanguageSelection:2015-7-28 10:06:25.583 UIMenuController[4735:388013] _accessibilityPauseSpeaking:2015-7-28 10:06:25.583 UIMenuController[4735:388013] _share:2015-7-28 10:06:25.584 UIMenuController[4735:388013] makeTextWritingDirectionRightToLeft:2015-7-28 10:06:25.584 UIMenuController[4735:388013] makeTextWritingDirectionLeftToRight: 设置第一响应者a. 前提是：必须要有第一响应者，让第一响应者，实现上面方法，告诉显示什么内容。实现下面方法，可以让某个视图或者控制器，成为第一响应者： canBecomeFirstResponder方法。 1234567/*** 说明控制器可以成为第一响应者*/- (BOOL)canBecomeFirstResponder&#123; return YES;&#125; 实现监听菜单内容的对应的action方法123456789101112 - (void)cut:(UIMenuController *)menu&#123; NSLog(@"%s %@", __func__, menu);&#125;- (void)copy:(UIMenuController *)menu&#123; NSLog(@"%s %@", __func__, menu);&#125;- (void)paste:(UIMenuController *)menu&#123; NSLog(@"%s %@", __func__, menu);&#125; 监听到menu菜单的显示与隐藏与frame改变的通知如下：监听menu即将显示的通知 1.注册通知监听// 注册监听 菜单即将显示 通知1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(show:) name:UIMenuControllerWillShowMenuNotification object:nil]; 2.实现监听到menu菜单显示调用方法1234- (void)dealloc&#123; // 移除监听通知 [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 3.dealloc方法中，移除通知监听1234- (void)dealloc&#123; // 移除监听通知 [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 设置menu支持中文，显示中文 -&gt;修改软件应用支持中文 解决方案：查看UIMenuController的头文件，我们发现有个属性menuItems数组，通过它我们可以增加额外的菜单项,自定义meun显示自己定义的文字 注意： 创建只能通过[UIMenuController sharedMenuController];单例方式获取，不能通过init方式创建，否则报如下错误获得菜单 -&gt; 回报如下错误 UIMenuController *menu = [[UIMenuController alloc] init]; Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;There can only be one UIMenuController instance.&apos; 三、应用 如何给Label添加UIMenuController功能1.设置UILabel允许交互2.给UILabel添加手势，3.在UILabel手势监听方法中，创建UIMenuController-》menu4.设置menu位置，利用UIMenuController的对象方法setTargetRect: inView:方法来设置menu显示在在那个控件的那个位置6.显示menu, -》 menu setMenuVisible: animation:7.设置menu显示内容注意：得通过第一响应者，来告诉menu它内部显示什么内容。如果显示中文标题，就需要手动设置APP支持中文实现：7.1让label成为第一响应者（注意：不一定第一响应者必须是控制器）7.2设置menu显示menuItem，告诉menu可以显示什么内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#import "JPLabel.h"@implementation JPLabel- (void)awakeFromNib&#123; // 给Label添加手势 [self addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(labelClick)]];&#125;- (void)initWithFrame:(CGRect)rect&#123; if(self = [super initWithFrame:rect])&#123; // 给Label添加手势 [self addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(labelClick)]]; &#125;&#125;- (void)labelClick&#123; // 让label成为第一响应者 [self becomeFirstResponder]; // 获得菜单 UIMenuController *menu = [UIMenuController sharedMenuController]; // 设置菜单内容，显示中文，所以要手动设置app支持中文 menu.menuItems = @[ [[UIMenuItem alloc] initWithTitle:@"顶" action:@selector(ding:)], [[UIMenuItem alloc] initWithTitle:@"回复" action:@selector(reply:)], [[UIMenuItem alloc] initWithTitle:@"举报" action:@selector(warn:)] ]; // 菜单最终显示的位置 [menu setTargetRect:self.bounds inView:self]; // 显示菜单 [menu setMenuVisible:YES animated:YES];&#125;#pragma mark - UIMenuController相关/** * 让Label具备成为第一响应者的资格 */- (BOOL)canBecomeFirstResponder&#123; return YES;&#125;/** * 通过第一响应者的这个方法告诉UIMenuController可以显示什么内容 */- (BOOL)canPerformAction:(SEL)action withSender:(id)sender&#123; if ( (action == @selector(copy:) &amp;&amp; self.text) // 需要有文字才能支持复制 || (action == @selector(cut:) &amp;&amp; self.text) // 需要有文字才能支持剪切 || action == @selector(paste:) || action == @selector(ding:) || action == @selector(reply:) || action == @selector(warn:)) return YES; return NO;&#125;#pragma mark - 监听MenuItem的点击事件- (void)cut:(UIMenuController *)menu&#123; // 将label的文字存储到粘贴板 [UIPasteboard generalPasteboard].string = self.text; // 清空文字 self.text = nil;&#125;- (void)copy:(UIMenuController *)menu&#123; // 将label的文字存储到粘贴板 [UIPasteboard generalPasteboard].string = self.text;&#125;- (void)paste:(UIMenuController *)menu&#123; // 将粘贴板的文字赋值给label self.text = [UIPasteboard generalPasteboard].string;&#125;- (void)ding:(UIMenuController *)menu&#123; NSLog(@"%s %@", __func__, menu);&#125;- (void)reply:(UIMenuController *)menu&#123; NSLog(@"%s %@", __func__, menu);&#125;- (void)warn:(UIMenuController *)menu&#123; NSLog(@"%s %@", __func__, menu);&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 汉字转换拼音 CFStringTransform]]></title>
      <url>%2F2016%2F06%2F13%2F16-06-13-CFStringTransform%2F</url>
      <content type="text"><![CDATA[参考原文 CFStringTransform 是 Core Foundation 中的一部分12CF_EXPORTBoolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse) 这个函数传入以下参数，并返回一个 Boolean 来表示转换是否成功：string: 需要转换的字符串。由于这个参数是 CFMutableStringRef 类型，一个 NSMutableString 类型也可以通过自由桥接的方式传入。range: 转换操作作用的范围。这个参数是 CFRange，而不是 NSRange。transform: 需要应用的变换。这个参数使用了包含下面将提到的字符串常量的 ICU transform string。reverse: 如有需要，是否返回反转过的变换。 CFStringTransform 中的 transform 参数涉及的内容很多。这里有个它能做什么的概述： 去掉重音和变音符Énġlišh långuãge lẳcks iñterêßţing diaçrïtičş. 如此类的字符串，把扩展的拉丁字符集正则化为 ASCII 友好型的表示，它非常有用。用 kCFStringTransformStripCombiningMarks 变换来去掉任意字符串中弯弯扭扭的符号。 为 Unicode 字符命名kCFStringTransformToUnicodeName 让你可以找出特殊字符的 Unicode 标准名，包括 Emoji。例如：”🐑💨✨” 被转换成 “{SHEEP} {DASH SYMBOL} {SPARKLES}”，而 “🐷” 变成了 “{PIG FACE}”。 不同拼写之间转写除了英语这个重大例外（和它那令人愉快的拼写不一致），书写系统一般是将语言音调编码成一致的符号表示。欧洲语言一般使用拉丁字母（外加一些变音符），俄罗斯用西里尔字母，日本用平假名和片假名，泰国、韩国和阿拉伯国家也都有自己的字母。 虽然每种语言都有特殊的音调列表，也许有些其他语言会缺失，所有主要书写系统的交集已经足以让你高效的在不同字母之间转写（不要跟翻译搞混了）。 CFStringTransform 可以在拉丁语和阿拉伯语、西里尔语、希腊语、韩语（韩国）、希伯来语、日语（平假名和片假名）、普通话、泰语之间来回转写。 并且这只是用了核心类库中常量定义！直接传入一个ICU transform表达式，CFStringTransform 还可以在拉丁语和阿拉伯语、亚美尼亚语、注音、西里尔字母、格鲁吉亚语、希腊语、汉语、韩语、希伯来语、平假名、印度语（梵文，古吉拉特语，旁遮普文，卡纳达语，马拉雅拉姆语，奥里雅语，泰米尔语，特卢固）、朝鲜语、片假名、叙利亚语、塔纳文、泰语之间转写。 平时可能会遇到的问题字符串变换的一个更实际的应用是正则化不可预知的用户输入。即使你的应用并不单独处理其他语言，你也应当能智能地处理用户向你的应用输入的任何内容。 例如，你想在设备上建立一个可搜索的电影索引，它包含世界各地的人的问候： 首先，应用 kCFStringTransformToLatin 变换将所有非英文文本转换为拉丁字母表示。Hello! こんにちは! สวัสดี! مرحبا! 您好! → Hello! kon’nichiha! s̄wạs̄dī! mrḥbạ! nín hǎo! 然后，应用 kCFStringTransformStripCombiningMarks 变换来去除变音符和重音。Hello! kon’nichiha! s̄wạs̄dī! mrḥbạ! nín hǎo! → Hello! kon’nichiha! swasdi! mrhba! nin hao! 最后，用 CFStringLowercase 转为小写，并用CFStringTokenizer 分词用作文本的索引。(hello, kon’nichiha, swasdi, mrhba, nin, hao) 通过对用户输入的文本使用同样的变换，你就可以实现一个通用的搜索，无论搜索文本或内容是什么语言！ 下面我提供一个包含如下两个方法的CategoryCategory下载地址1234567891011121314151617181920212223242526272829303132333435/** * 汉字转成没有声调有空格的拼音 * (空格可根据需求调整return的withString后的字符串) * @param wordStr 需要拼音的汉字(词组/句子) * * @return 拼音 */+ (NSString *)transformToPinYin:(NSString *)wordStr &#123; NSMutableString *mutableString = [NSMutableString stringWithString:wordStr]; //带声调 CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, NO); // //不带声调 CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformStripDiacritics, NO); //你好 -&gt; ni hao -&gt; nihao return [mutableString stringByReplacingOccurrencesOfString:@" " withString:@" "];&#125;/** * 汉字转成有声调有空格的拼音 * (空格可根据需求调整return的withString后的字符串) * @param wordStr 需要拼音的汉字(词组/句子) * * @return 带声调的拼音 */+ (NSString *)transformToPinYinHaveTone:(NSString *)wordStr &#123; NSMutableString *mutableString = [NSMutableString stringWithString:wordStr]; //带声调 CFStringTransform((CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, NO); //你好 -&gt; ni hao -&gt; nihao return [mutableString stringByReplacingOccurrencesOfString:@" " withString:@" "];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS Web service SOAP消息(基于AFNetworking)]]></title>
      <url>%2F2016%2F06%2F07%2F16-06-07-AFNetworking-SOAP%2F</url>
      <content type="text"><![CDATA[Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。Web Service技术， 能使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件， 就可相互交换数据或集成。依据Web Service规范实施的应用之间， 无论它们所使用的语言、 平台或内部协议是什么， 都可以相互交换数据。Web Service是自描述、 自包含的可用网络模块， 可以执行具体的业务功能。Web Service也很容易部署， 因为它们基于一些常规的产业标准以及已有的一些技术，诸如标准通用标记语言下的子集XML、HTTP。Web Service减少了应用接口的花费。Web Service为整个企业甚至多个组织之间的业务流程的集成提供了一个通用机制。 下面分别是AFNetworking 2.6和3.0的关键代码，如想要Demo的，留言给我 AFNetworking 3.012345678910111213141516171819202122232425262728#pragma mark - 发送请求/** * 发送请求 */- (void)webServiceRequestWithsoapMessage:(NSString *)soapMessage &#123; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url11]; [request addValue:@"text/xml; charset=utf-8" forHTTPHeaderField:@"Content-Type"]; [request setHTTPMethod:@"POST"]; [request setHTTPBody:[soapMessage dataUsingEncoding:NSUTF8StringEncoding]]; NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration]; manager.responseSerializer = [AFXMLParserResponseSerializer serializer]; NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) &#123; if (error) &#123; NSLog(@"Error: %@", [error description]); &#125; else &#123; [responseObject setDelegate:self]; [responseObject parse]; &#125; &#125;]; [dataTask resume];&#125; AFNetworking 2.61234567891011121314151617181920212223242526272829#pragma mark - 发送请求/** * 发送请求 */- (void)webServiceRequestWithsoapMessage:(NSString *)soapMessage &#123; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; [request addValue:@"text/xml; charset=utf-8" forHTTPHeaderField:@"Content-Type"]; [request setHTTPMethod:@"POST"]; [request setHTTPBody:[soapMessage dataUsingEncoding:NSUTF8StringEncoding]]; AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request]; operation.responseSerializer = [AFXMLParserResponseSerializer serializer]; [operation setCompletionBlockWithSuccess:^( AFHTTPRequestOperation *_Nonnull operation, id _Nonnull responseObject) &#123; NSLog(@"请求成功：%@", [responseObject description]); /** * 解析xml */ [responseObject setDelegate:self]; [responseObject parse]; &#125; failure:^(AFHTTPRequestOperation *_Nonnull operation, NSError *_Nonnull error) &#123; NSLog(@"请求失败%@", error); &#125;]; [operation start];&#125; 如果需要Demo，请在文章下面给我留言]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 使用 ASI 调webService]]></title>
      <url>%2F2016%2F05%2F25%2F16-05-25-ASI-WebService%2F</url>
      <content type="text"><![CDATA[Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。Web Service技术， 能使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件， 就可相互交换数据或集成。依据Web Service规范实施的应用之间， 无论它们所使用的语言、 平台或内部协议是什么， 都可以相互交换数据。Web Service是自描述、 自包含的可用网络模块， 可以执行具体的业务功能。Web Service也很容易部署， 因为它们基于一些常规的产业标准以及已有的一些技术，诸如标准通用标记语言下的子集XML、HTTP。Web Service减少了应用接口的花费。Web Service为整个企业甚至多个组织之间的业务流程的集成提供了一个通用机制。 步骤: 添加SystemConfiguration.framework和libz.tbd 将asi中类添加不使用arc标志 下面上代码 Demo下载 我们使用的是xml传输数据，其中XML创建和解析我使用的是GDataXML，下面先说说xml的生成和解析 通过实体类生成xml字符串，实体类的具体属性就不一一贴出了具体通过需求而定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#pragma mark - xml文件创建/** * xml文件创建 * * @return 创建好的XML字符串 */- (NSString *)requestXmlStringCreateWithArgs:(NSArray *)args &#123; /** * 创建一个标签元素 一级标签 * 如果value不设置值，生成的标签为&lt;soapenv:Header/&gt; */ GDataXMLElement *element = [GDataXMLNode elementWithName:@"soapenv:Header" stringValue:@""]; GDataXMLElement *element12 = [GDataXMLNode elementWithName:@"soapenv:Body" stringValue:@""]; // 创建一个标签元素 二级标签 GDataXMLElement *element21 = [GDataXMLNode elementWithName:@"" stringValue:@""]; /** 获取当前类的属性列表 */ PayModel *payModel = [[PayModel alloc] init]; NSArray *propertyList = [payModel propertyNameList]; [args enumerateObjectsUsingBlock:^(PayModel *obj, NSUInteger idx, BOOL *_Nonnull stop) &#123; GDataXMLElement *arg = [GDataXMLNode elementWithName:[NSString stringWithFormat:@"zz%zd", idx] stringValue:@""]; for (int i = 0; i &lt; [propertyList count]; i++) &#123; // 创建一个标签元素 四级标签 存储内容 if ([obj valueForKey:propertyList[i]] != nil) &#123; GDataXMLElement *element41 = [GDataXMLNode elementWithName:propertyList[i] stringValue:[obj valueForKey:propertyList[i]]]; [arg addChild:element41]; &#125; &#125; [element21 addChild:arg]; &#125;]; // 创建一个属性 根标签属性 GDataXMLElement *rootElementAttribute1 = [GDataXMLNode attributeWithName:@"xmlns:" stringValue:@"根据情况而定"]; GDataXMLElement *rootElementAttribute2 = [GDataXMLNode attributeWithName:@"" stringValue:@"根据情况而定"]; // 创建一个根标签 GDataXMLElement *rootElement = [GDataXMLNode elementWithName:@":"]; //将二级标签添加到一级标签上 [element12 addChild:element21]; // 把标签与属性添加到根标签中 [rootElement addChild:element]; [rootElement addChild:element12]; [rootElement addAttribute:rootElementAttribute1]; [rootElement addAttribute:rootElementAttribute2]; // 生成xml文件内容 GDataXMLDocument *xmlDoc = [[GDataXMLDocument alloc] initWithRootElement:rootElement]; NSData *data = [xmlDoc XMLData]; NSString *xmlString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; return xmlString;&#125; 解析xml1234567891011121314151617181920212223#pragma mark - 解析xml/** * 解析xml */- (void)pareXMLWithXMLString:(NSString *)xmlString &#123; GDataXMLDocument *xmlDoc = [[GDataXMLDocument alloc] initWithXMLString:xmlString encoding:NSUTF8StringEncoding error:nil]; GDataXMLElement *rootElement = [xmlDoc rootElement]; for (GDataXMLElement *ele in rootElement.children) &#123; if (ele.childCount &gt; 0) &#123; for (GDataXMLElement *ele1 in ele.children) &#123; for (GDataXMLElement *ele2 in ele1.children) &#123; for (GDataXMLElement *ele3 in ele2.children) &#123; NSLog(@"标签名：%@\n", ele3.name); NSLog(@"内容：%@\n", ele3.stringValue); &#125; &#125; &#125; &#125; &#125;&#125; 发送请求123456789101112131415161718192021222324252627282930#pragma mark - 发送请求- (void)webServiceRequestWithsoapMessage:(NSString *)soapMessage &#123; NSURL *url = [NSURL URLWithString:urlString]; //请求发送到的路径 ASIHTTPRequest *theRequest = [ASIHTTPRequest requestWithURL:url]; [theRequest addRequestHeader:@"Content-Type" value:@"text/xml; charset=utf-8"]; [theRequest setRequestMethod:@"POST"]; [theRequest appendPostData:[soapMessage dataUsingEncoding:NSUTF8StringEncoding]]; [theRequest setDefaultResponseEncoding:NSUTF8StringEncoding]; [theRequest startSynchronous]; NSError *error = [theRequest error]; if (!error) &#123; NSMutableData *mData = [NSMutableData dataWithData:[theRequest responseData]]; // WebService接口返回的数据 NSString *theXML = [[NSString alloc] initWithBytes:[mData mutableBytes] length:[mData length] encoding: NSUTF8StringEncoding]; //将返回数据转换为字符串，进行解析（本文中返回的数据为XML数据） NSLog(@"%@", theXML); /** * 解析xml */ [self pareXMLWithXMLString:theXML]; &#125; else &#123; NSLog(@"请求错误：\n%@", error); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS Touch ID]]></title>
      <url>%2F2016%2F05%2F23%2F16-05-23-TouchID%2F</url>
      <content type="text"><![CDATA[Touch ID指纹识别作为iPhone 5s上的“杀手级”功能早已为人们所熟知，iphone SE、iPhone 6、iPhone 6Puls、iPhone 6s、iPhone 6s Plus、iPad Pro、iPad mini 4、iPad mini 3和iPad air 2也使用了Touch ID。 苹果把用户的指纹数据存放在处理器的安全区域（Secure Enclave）中，充分保护用户的数据安全。除此之外，苹果还有另外一道指纹数据安全防线，以一种前所未有的硬件技术实现了对用户数据的保护。 效果展示 Demo下载 具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071先导入LocalAuthentication.framework#import &lt;LocalAuthentication/LocalAuthentication.h&gt;- (void)authenticateUser &#123; //初始化上下文对象 LAContext *context = [[LAContext alloc] init]; //错误对象 NSError *error = nil; //使用canEvaluatePolicy 判断设备支持状态 if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) &#123; //支持指纹验证 [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:@"TouchID 测试" //显示的文本 reply:^(BOOL success, NSError *error) &#123; if (success) &#123; NSLog(@"验证成功，主线程处理UI"); &#125; else &#123; NSLog(@"%@", error.localizedDescription); switch (error.code) &#123; case LAErrorSystemCancel: &#123; NSLog(@"切换到其他APP，系统取消验证Touch " @"ID"); //切换到其他APP，系统取消验证Touch ID break; &#125; case LAErrorUserCancel: &#123; //用户取消验证Touch ID NSLog(@"用户取消验证Touch ID"); break; &#125; case LAErrorUserFallback: &#123; NSLog( @"用" @"户选择输入密码，切换主线程处理"); [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; NSLog( @"用" @"户" @"选择输入密码，切换主线程处理"); &#125;]; break; &#125; default: &#123; [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; NSLog(@"其他情况，切换主线程处理"); &#125;]; break; &#125; &#125; &#125; &#125;]; &#125; else &#123; //不支持指纹识别，LOG出错误详情 switch (error.code) &#123; case LAErrorTouchIDNotEnrolled: &#123; NSLog(@"设备Touch ID不可用，用户未录入"); break; &#125; case LAErrorPasscodeNotSet: &#123; NSLog(@"系统未设置密码"); break; &#125; default: &#123; NSLog(@"TouchID不可用"); break; &#125; &#125; NSLog(@"%@", error.localizedDescription); &#125;&#125; 错误失败信息： 连续三次指纹识别错误：Aplication retry limit exceeded Touch ID功能被锁定，下一次需要输入系统密码：Biometry is locked out 用户在Touch ID对话框中点击了取消按钮Canceled by user 在Touch ID对话框显示过程中，背系统取消，例如按下电源键：UI canceled by system 用户在Touch ID对话框中点击输入密码按钮：Fallback authentication mechanism selected 目标设备不支持指纹识别Biometry is not available on this device //真机Simulator is not supported //模拟器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 大部分页面竖屏显示，个别页面横屏显示]]></title>
      <url>%2F2016%2F05%2F23%2F16-05-23-supportedInterfaceOrientationsForWindow%2F</url>
      <content type="text"><![CDATA[我将横屏显示的controller显示了statusBar将将背景色显示成透明效果如下图 Demo下载 在AppDelegate中添加需要横屏显示的代码12345678910111213141516171819202122232425262728/** * 横竖屏幕切换 * NaviViewController为我设置的根控制器 * controller需要横屏显示的控制器 */- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123; __block UIInterfaceOrientationMask mask = 0; for (UIWindow *subWindow in [UIApplication sharedApplication].windows) &#123; // NaviViewController为我设置的根控制器 if ([subWindow.rootViewController isKindOfClass:NSClassFromString(@"NaviViewController")]) &#123; NSArray *arrays = [subWindow.rootViewController childViewControllers]; [arrays enumerateObjectsUsingBlock:^( UIViewController *obj, NSUInteger idx, BOOL *_Nonnull stop) &#123; //需要横屏显示的controller if ([obj isKindOfClass:NSClassFromString(@"ViewController11")]) &#123; mask = UIInterfaceOrientationMaskAll; return; &#125; else &#123; mask = UIInterfaceOrientationMaskPortrait; return; &#125; &#125;]; &#125; &#125; return mask;&#125; 需要横屏或旋转显示的页面1234567/** * 使用此句代码，会调用delegate里面的supportedInterfaceOrientationsForWindow方法 * 默认显示numberWithInteger后的类型 */[[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:UIDeviceOrientationLandscapeRight] forKey:@"orientation"];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设置navigationBar背景透明]]></title>
      <url>%2F2016%2F05%2F20%2F16-05-20-navigationBarBackgroundTransparent%2F</url>
      <content type="text"><![CDATA[效果如下图红色窗体 我将此方法放在了一个Category里面，下载请点击此链接下载代码设置NavigationBar背景为透明1234/** * 将navigationBar背景颜色设置为透明 */[self setNavigationBarBackgroundShow:NO]; 设置NavigationBar背景恢复不透明1234/** * 将navigationBar显示背景颜色 */ [self setNavigationBarBackgroundShow:YES]; 方法实现1234567891011121314151617181920212223242526/** * 状态栏是否显示背景色 * * @param show yes为显示背景色，否则为透明 */- (void)setNavigationBarBackgroundShow:(BOOL)show &#123; // 设置为半透明 self.navigationController.navigationBar.translucent = !show; UIColor *color = nil; if (show) &#123; color = [UIColor whiteColor]; &#125; else &#123; color = [UIColor clearColor]; &#125; CGRect rect = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.height, 64); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); [self.navigationController.navigationBar setBackgroundImage:image forBarMetrics:UIBarMetricsDefault]; self.navigationController.navigationBar.clipsToBounds = !show;&#125; 我在做这个的时候遇到过一个问题，navigationBar透明之后当前控制器的高不够，显示出的是其它控制器解决：我将当前控制器的高调整成了屏幕的高]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设置statusBar背景色]]></title>
      <url>%2F2016%2F05%2F13%2FstatusBarBackgroundColor%2F</url>
      <content type="text"><![CDATA[本文使用iOS9.3 本人写的这个有一个侧滑，开始只在navigationController中将状态栏设置成了light，发现不行，后来将侧滑的控制器也设置成了白色，才可以 设置statusBar背景颜色12345[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]]; UIView *statusBarView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 20)]; statusBarView.backgroundColor = [UIColor blackColor]; [self.view addSubview:statusBarView]; 设置statusBar文字及电池的颜色123- (UIStatusBarStyle)preferredStatusBarStyle &#123; return UIStatusBarStyleLightContent;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[十六进制字符串NSString转换为NSData]]></title>
      <url>%2F2016%2F05%2F09%2F16-05-09-NSStringConvertNSData%2F</url>
      <content type="text"><![CDATA[下面提供的是一个NSString的Category 下载Category代码.h文件如下，具体实现在下面一个代码块中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#import &lt;Foundation/Foundation.h&gt;@interface NSString (Trans)/** * 十六 进制字符串转换为 data * 24211D3498FF62AF --&gt; &lt;24211D34 98FF62AF&gt; * * @param str 要转换的字符串 * * @return 转换后的数据 */+ (NSData*)hexToBytes:(NSString *)str;/** * data 转换为十六进制字符串 * &lt;24211D34 98FF62AF&gt; --&gt; 24211D3498FF62AF * * @param data 要转换的data * * @return 转换后的字符串 */+ (NSString *)hexStringFromData:(NSData *)data;/** * 由byte转为字符串 * * @param byteVal byte * * @return */+ (NSString *)stringFromByte:(Byte)byteVal;/** * hex字符串转为ASC码 00 --&gt; 3030 * * @param hex hex字符串 * * @return 转码后的ASC字符串 */+ (NSString *)hexToAsc:(NSString *)hex;/** * ASC码转为Hex字符串 3030 --&gt; 00 * * @param asc ASC字符串 * * @return 转码后的Hex字符串 */+ (NSString *)ascToHex:(NSString *)asc;/** * 十六进制字符串转二进制字符串 * * @param hex 十六进制字符串 * * @return 二进制字符串 */+(NSString *)HexToBinary:(NSString *)hex;/** * 2进制字符串转16进制字符串,如 11110011 -&gt; F3 * * @param Binary 二进制字符串 * * @return 16进制字符串 */+(NSString *)BinaryToHex:(NSString *)Binary;@end .m文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#import "NSString+Trans.h"****@implementation NSString (Trans)+(NSData*)hexToBytes:(NSString *)str&#123; NSMutableData* data = [NSMutableData data]; int idx; for (idx = 0; idx+2 &lt;= str.length; idx+=2) &#123; NSRange range = NSMakeRange(idx, 2); NSString* hexStr = [str substringWithRange:range]; NSScanner* scanner = [NSScanner scannerWithString:hexStr]; unsigned int intValue; [scanner scanHexInt:&amp;intValue]; [data appendBytes:&amp;intValue length:1]; &#125; return data;&#125;+ (NSString *)hexStringFromData:(NSData *)data&#123; NSMutableString *str = [NSMutableString string]; Byte *byte = (Byte *)[data bytes]; for (int i = 0; i&lt;[data length]; i++) &#123; // byte+i为指针 [str appendString:[self stringFromByte:*(byte+i)]]; &#125; return str;&#125;+ (NSString *)stringFromByte:(Byte)byteVal&#123; NSMutableString *str = [NSMutableString string]; //取高四位 Byte byte1 = byteVal&gt;&gt;4; //取低四位 Byte byte2 = byteVal &amp; 0xf; //拼接16进制字符串 [str appendFormat:@"%x",byte1]; [str appendFormat:@"%x",byte2]; return str;&#125;/** * hex字符串转为ASC码 00 --&gt; 3030 * * @param hex hex字符串 * * @return 转码后的ASC字符串 */+ (NSString *)hexToAsc:(NSString *)hex&#123; char szData[1024]=&#123;0&#125;; const char *pBytes = [hex UTF8String]; if(NULL != pBytes) &#123; for(int i=0; i&lt;hex.length; i++) &#123; char tmp[16]; sprintf(tmp, "%0.2X",pBytes[i]); strcat(szData, tmp); &#125; return [NSString stringWithFormat:@"%s",szData]; &#125; return nil;&#125;/** * ASC吗转为Hex字符串 3030 --&gt; 00 * * @param asc ASC字符串 * * @return 转码后的Hex字符串 */+ (NSString *)ascToHex:(NSString *)asc&#123; char szData[1024]=&#123;0&#125;; const char *ascBytes = [asc UTF8String]; if (NULL != ascBytes) &#123; [self ascToHex:ascBytes len:asc.length outAscii:szData]; return [NSString stringWithFormat:@"%s",szData]; &#125; return nil;&#125;+ (void)ascToHex:(const char *)hex len:(NSUInteger)length outAscii:(char *)ascii&#123; for (int i = 0; i &lt; length; i += 2) &#123; if (hex[i] &gt;= '0' &amp;&amp; hex[i] &lt;= '9') ascii[i / 2] = (hex[i] - '0') &lt;&lt; 4; else if (hex[i] &gt;= 'a' &amp;&amp; hex[i] &lt;= 'z') ascii[i / 2] = (hex[i] - 'a' + 10) &lt;&lt; 4; else if (hex[i] &gt;= 'A' &amp;&amp; hex[i] &lt;= 'Z') ascii[i / 2] = (hex[i] - 'A' + 10) &lt;&lt; 4; if (hex[i + 1] &gt;= '0' &amp;&amp; hex[i + 1] &lt;= '9') ascii[i / 2] += hex[i + 1] - '0'; else if (hex[i + 1] &gt;= 'a' &amp;&amp; hex[i + 1] &lt;= 'z') ascii[i / 2] += hex[i + 1] - 'a' + 10; else if (hex[i + 1] &gt;= 'A' &amp;&amp; hex[i + 1] &lt;= 'Z') ascii[i / 2] += hex[i + 1] - 'A' + 10; &#125;&#125;/** * 十六进制字符串转二进制字符串 * * @param hex 十六进制字符串 * * @return 二进制字符串 */+(NSString *)HexToBinary:(NSString *)hex&#123; NSMutableDictionary *hexDic = [[NSMutableDictionary alloc] init]; hexDic = [[NSMutableDictionary alloc] initWithCapacity:16]; [hexDic setObject:@"0000" forKey:@"0"]; [hexDic setObject:@"0001" forKey:@"1"]; [hexDic setObject:@"0010" forKey:@"2"]; [hexDic setObject:@"0011" forKey:@"3"]; [hexDic setObject:@"0100" forKey:@"4"]; [hexDic setObject:@"0101" forKey:@"5"]; [hexDic setObject:@"0110" forKey:@"6"]; [hexDic setObject:@"0111" forKey:@"7"]; [hexDic setObject:@"1000" forKey:@"8"]; [hexDic setObject:@"1001" forKey:@"9"]; [hexDic setObject:@"1010" forKey:@"A"]; [hexDic setObject:@"1011" forKey:@"B"]; [hexDic setObject:@"1100" forKey:@"C"]; [hexDic setObject:@"1101" forKey:@"D"]; [hexDic setObject:@"1110" forKey:@"E"]; [hexDic setObject:@"1111" forKey:@"F"]; NSMutableString *binaryString=[[NSMutableString alloc] init]; for (int i=0; i&lt;[hex length]; i++) &#123; NSString *key = [hex substringWithRange:NSMakeRange(i, 1)]; [binaryString appendString:[NSString stringWithFormat:@"%@",[hexDic objectForKey:key]]]; &#125; return binaryString;&#125;/** * 2进制字符串转16进制字符串,如 11110011 -&gt; F3 * * @param Binary 二进制字符串 * * @return 16进制字符串 */+(NSString *)BinaryToHex:(NSString *)Binary&#123; if ([Binary length]%4 == 0) &#123; NSMutableDictionary *hexDic = [[NSMutableDictionary alloc] init]; hexDic = [[NSMutableDictionary alloc] initWithCapacity:16]; [hexDic setObject:@"0" forKey: @"0000"]; [hexDic setObject:@"1" forKey: @"0001"]; [hexDic setObject:@"2" forKey: @"0010"]; [hexDic setObject:@"3" forKey: @"0011"]; [hexDic setObject:@"4" forKey: @"0100"]; [hexDic setObject:@"5" forKey: @"0101"]; [hexDic setObject:@"6" forKey: @"0110"]; [hexDic setObject:@"7" forKey: @"0111"]; [hexDic setObject:@"8" forKey: @"1000"]; [hexDic setObject:@"9" forKey: @"1001"]; [hexDic setObject:@"A" forKey: @"1010"]; [hexDic setObject:@"B" forKey: @"1011"]; [hexDic setObject:@"C" forKey: @"1100"]; [hexDic setObject:@"D" forKey: @"1101"]; [hexDic setObject:@"E" forKey: @"1110"]; [hexDic setObject:@"F" forKey: @"1111"]; NSMutableString *hexString=[[NSMutableString alloc] init]; for (int i=0; i&lt;[Binary length]/4; i++) &#123; NSString *key = [Binary substringWithRange:NSMakeRange(4*i, 4)]; // hexString = [NSString stringWithFormat:@"%@%@",binaryString,[NSString stringWithFormat:@"%@",[hexDic objectForKey:key]]]; [hexString appendString:[NSString stringWithFormat:@"%@",[hexDic objectForKey:key]]]; &#125; return hexString; &#125;else return nil;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义Label行高和首行缩进]]></title>
      <url>%2F2016%2F05%2F05%2F16-05-05-labelLineHeightAndtextIndex%2F</url>
      <content type="text"><![CDATA[首行缩进和控制行距放到了UILabel+LineSpacing_textIndex Category里 缩进和自定义行间距的效果如下图 下面的两段代码是方法调用，Category的具体代码，在文章的最后面，或是点击下载Category链接下载首行缩进使用，具体代码可以下载Category首行缩进是根据文字个数进行缩进，传的TypeNum为要缩进的文字数123456789101112131415161718192021222324#import "UILabel+LineSpacing_textIndex.h"#import "ViewController.h"@interface ViewController ()@property(weak, nonatomic) IBOutlet UILabel *contentLabel;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.contentLabel.text = @"简单点说话的方式简单点" @"递进的情绪请省略" @"你又不是个演员" @"别设计那些情节" @"没意见我只想看看你怎么圆" @"你难过的太表面 像没天赋的演员" @"观众一眼能看见" @"该配合你演出的我演视而不见" @"在逼一个最爱你的人即兴表演" @"什么时候我们开始收起了底线" @"顺应时代的改变看那些拙劣的表演" @"可你曾经那么爱我干嘛演出细节"; //首行缩进 [self.contentLabel textIndexWithTypeNum:2];&#125;@end 修改行间距的方法调用，具体代码可以下载Category123456789101112131415161718192021222324#import "UILabel+LineSpacing_textIndex.h"#import "ViewController.h"@interface ViewController ()@property(weak, nonatomic) IBOutlet UILabel *contentLabel;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.contentLabel.text = @"简单点说话的方式简单点" @"递进的情绪请省略" @"你又不是个演员" @"别设计那些情节" @"没意见我只想看看你怎么圆" @"你难过的太表面 像没天赋的演员" @"观众一眼能看见" @"该配合你演出的我演视而不见" @"在逼一个最爱你的人即兴表演" @"什么时候我们开始收起了底线" @"顺应时代的改变看那些拙劣的表演" @"可你曾经那么爱我干嘛演出细节"; //修改行距 [self.contentLabel lineSpaceingWithLineSpacingNum:12];&#125;@end 下面是Category中的代码首行缩进的方法调用123456789101112131415161718192021222324/** * 根据传入的字数确认首行缩进的字数 * * @param typeNum 首行缩进的字数 */- (void)textIndexWithTypeNum:(NSUInteger)typeNum &#123; NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:self.text]; NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init]; paragraphStyle.alignment = NSTextAlignmentLeft; CGFloat labelFont = [[self font] pointSize]; CGSize whSize = [self.text sizeWithAttributes:@&#123; NSFontAttributeName : [UIFont systemFontOfSize:labelFont] &#125;]; [paragraphStyle setFirstLineHeadIndent:whSize.height * typeNum - typeNum * 2.5]; //首行缩进 根据用户昵称宽度在加5个像素 [attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [self.text length])]; self.attributedText = attributedString;&#125; 设置行间距123456789101112131415161718/** * 设置行间距 * * @param lineSpacingNum 行间距值 */- (void)lineSpaceingWithLineSpacingNum:(NSUInteger)lineSpacingNum &#123; NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:self.text]; NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init]; paragraphStyle.maximumLineHeight = lineSpacingNum; //最大的行高 [attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [self.text length])]; self.attributedText = attributedString; [self sizeToFit];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bug记录-deflate_referenced_from]]></title>
      <url>%2F2016%2F05%2F03%2F16-05-03-bug%2F</url>
      <content type="text"><![CDATA[title: Bug记录-deflate,referenced from:date: 2016-05-03 21:27:40 tags:参考 123Undefined symbols for architecture i386:"_SCNetworkReachabilityCreateWithAddress", referenced from:"_SCNetworkReachabilityGetFlags", referenced from: 解决办法：添加SystemConfiguration.framework 这个是引用NSDataAdditions时出现的bug， 123456789101112"_deflate", referenced from: -[NSData(NSDataAdditions) gzipDeflate] in NSDataAdditions.o "_deflateEnd", referenced from: -[NSData(NSDataAdditions) gzipDeflate] in NSDataAdditions.o "_deflateInit2_", referenced from: -[NSData(NSDataAdditions) gzipDeflate] in NSDataAdditions.o "_inflate", referenced from: -[NSData(NSDataAdditions) gzipInflate] in NSDataAdditions.o "_inflateEnd", referenced from: -[NSData(NSDataAdditions) gzipInflate] in NSDataAdditions.o "_inflateInit2_", referenced from: -[NSData(NSDataAdditions) gzipInflate] in NSDataAdditions.o 解决办法：添加libz.dylib类库 ‘libxml/HTMLpraser.h’ file not found 这个是一位网友在xcode4.3.2中编译没问题，但是在xcode4.6.3中编译是遇到的，给的解决步骤 添加libxml2.2.dylib类库 在Build Settings-&gt;Other Liner Flags此项中添加-lxml2,如下图 在Build Settings-&gt;Header Search Paths项添加/usr/include/libxml2,如下图 据这位网友讲，修复过后报错armv7s，armv7s的问题比较常见的解决办法是在Build Settings-&gt;Valid Architectures项中去除armv7s，如果还是未能解决，请谷歌armv7s查找具体解决办法 PS：用第三方类库.a文件时很容易出现无法解决的armv7s问题，尤其是好多类库都比较老，但是苹果的类库和XCode一直在更新，很容易出现未知错误，建议用第三方库时导入.m文件，比较容易解决问题 selector警告1performSelector may cause a leak because its selector is unknown 触发原因12SEL sel = @selector(touch:);[self performSelector:sel withObject:textField]; 解决办法123#import &lt;objc/message.h&gt;SEL sel = @selector(touch:);objc_msgSend(self, sel, textField);// textField为touch：后跟的参数，如有多个参数，用','连接即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取当前类所有属性]]></title>
      <url>%2F2016%2F05%2F03%2F16-05-03-runtime-getPropertyNameList%2F</url>
      <content type="text"><![CDATA[**class_copyPropertyList**： 返回对象类的属性(@property声明的属性) **class_copyIvarList**：返回类的所有属性和变量(包括在@interface大括号中声明的变量) 通过runtime获取当前类@property声明的属性列表 1234567891011121314151617181920#import &lt;objc/runtime.h&gt;@implementation PayModel- (NSArray *)getPropertyNameList &#123; unsigned int count; // 返回对象类的属性(@property声明的属性) objc_property_t *properties = class_copyPropertyList([self class], &amp;count); //存储属性列表 NSMutableArray *propertyNameList = [NSMutableArray array]; for (int i = 0; i &lt; count; i++) &#123; objc_property_t property = properties[i]; // property_getName返回一个CString // 将CString转换为NSString NSString *str = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; [propertyNameList addObject:str]; &#125; free(properties); return [propertyNameList copy];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[迪士尼七宝]]></title>
      <url>%2F2016%2F05%2F02%2F16-05-02-%E8%BF%AA%E5%A3%AB%E5%B0%BC%E4%B8%83%E5%AE%9D%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片压缩]]></title>
      <url>%2F2016%2F05%2F02%2F16-05-02-pictureCompress%2F</url>
      <content type="text"><![CDATA[可以将如下两个方法写在分类中,方便不同项目的重复使用 123456//压缩图片质量+ (UIImage*)reduceImage:(UIImage*)image percent:(float)percent &#123; NSData* imageData = UIImageJPEGRepresentation(image, percent); UIImage* newImage = [UIImage imageWithData:imageData]; return newImage;&#125; 12345678910111213//压缩图片尺寸+ (UIImage*)imageWithImageSimple:(UIImage*)image scaledToSize:(CGSize)newSize &#123; // Create a graphics image context UIGraphicsBeginImageContext(newSize); // new size [image drawInRect:CGRectMake(0, 0, newSize.width, newSize.height)]; // Get the new image from the context UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext(); // End the context UIGraphicsEndImageContext(); // Return the new image. return newImage;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取storyboard箭头指向的根控制器]]></title>
      <url>%2F2016%2F05%2F02%2F16-05-02-%E8%8E%B7%E5%8F%96storyboard%E7%AE%AD%E5%A4%B4%E6%8C%87%E5%90%91%E7%9A%84%E6%A0%B9%E6%8E%A7%E5%88%B6%E5%99%A8%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122/** * 通过名称获取storyboard箭头指向的根控制器 * * @param sbName storyboard名字 * * @return storyboard instantiateInitialViewController */- (id)viewControllerWithSBName:(NSString*)sbName &#123;//获取程序的名字 NSDictionary* info = [[NSBundle mainBundle] infoDictionary]; NSString* prodName = [info objectForKey:@"CFBundleExecutable"]; NSString* sbPath = [NSString stringWithFormat:@"%@/%@/", prodName, sbName]; // NSLog(@"%@", [[UIStoryboard // storyboardWithName:sbName // bundle:[[NSBundle alloc] // initWithPath:sbPath]] // instantiateInitialViewController]); return [[UIStoryboard storyboardWithName:sbName bundle:[[NSBundle alloc] initWithPath:sbPath]] instantiateInitialViewController];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH公钥]]></title>
      <url>%2F2016%2F05%2F02%2F16-05-02-ssh%E5%85%AC%E9%92%A5%2F</url>
      <content type="text"><![CDATA[SSH （ Secure Shell）是一种安全协议，在你的电脑与 GitHub 服务器进行通信时，我们使用 SSH 密钥（SSH Keys）认证的方式来保证通信安全。 SSH 密钥的创建需要在终端（命令行）环境下进行，我们首先进入命令行环境。通常在 Mac OS X 和 Linux 平台下我们使用终端工具（Terminal），在 Windows 平台中，可以使用 Git Bash 工具。 进入命令行环境后，我们执行以下操作来创建 SSH 密钥 1. 进入 SSH 目录1cd ~/.ssh 如果还没有 /.ssh 目录，可以手工创建一个 mkdir /.ssh，之后再通过 cd /.ssh 进入 SSH 目录 可以通过 ls 命令查看 SSH 目录下的文件，来确认你是否已经生成过 SSH 密钥；如果 SSH 目录为空，我们开始第二步，生成 SSH 密钥；如果存在 id_rsa.pub 这个文件，说明你之前生成过 SSH 密钥，可以跳过第二步，直接进行密钥的获取。 2. 生成 SSH 密钥我们通过下面的命令生成密钥，请将命令中的 YOUR_EMAIL@YOUREMAIL.COM 替换为你自己的 Email 地址。 1ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM" 在 SSH 生成过程中会出现以下信息，按屏幕的提示操作即可；当提示Enter passphrase ( empty for no passphrase ) : 时，可以直接按两次回车键输入一个空的 passphrase；也可以选择输入一个 passphrase 口令，如果此时你输入了一个 passphrase，请牢记，之后每次提交时都需要输入这个口令来确认。 12345678`$ ssh-keygen -t rsa -C "YOUR_EMAIL@YOUREMAIL.COM"Generating public/private rsa key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /Users/USERNAME/.ssh/id_rsa.Your public key has been saved in /Users/USERNAME/.ssh/id_rsa.pub.The key fingerprint is:15:81:d2:7a:c6:6c:0f:ec:b0:b6:d4:18:b8:d1:41:48 YOUR_EMAIL@YOUREMAIL.COM `一般情况下，在命令行中输入密码、口令一类的信息时是没有信息回显的。在我们这一步的操作中，输入 passphrase 口令时，命令行界面上不会随着键盘敲入密码而有什么反馈。 3. 获取 SSH 公钥信息1cat id_rsa.pub SSH 秘钥生成结束后，你可以在 SSH 目录下看到私钥 id_rsa 和公钥 id_rsa.pub 这两个文件，不要把私钥文件 id_rsa 的信息透露给任何人。我们可以通过文本编辑器或 cat 命令来查看 id_rsa.pub 公钥信息。 通过编辑器。使用你熟悉的文本编辑器，比如 记事本、Sublime Text 等软件打开 id_rsa.pub ，复制里面的所有内容以备下一步使用。 通过 cat命令。在命令行中敲入 **cat id_rsa.pub** ，回车执行后命令行界面中会显示 id_rsa.pub 文件里的内容，复制后在下一步使用。 5. 测试 GitHub SSH 连接完成上面的操作后，可以通过下面的命令来测试一下是否可以连接服务器。 1ssh -T git@github.com 如果你操作的电脑是第一次与 GitHub 建立连接，会出现以下警告， The authenticity of host &apos;github.com (50.116.2.223)&apos; can&apos;t be established. # RSA key fingerprint is 84:9e:c9:8e:7f:36:28:08:7e:13:bf:43:12:74:11:4e. # Are you sure you want to continue connecting (yes/no)? 输入 yes 后回车。此时，如果你在生成 SSH 密钥时设置了 passphrase 口令，会提示你输入口令，输入后回车即可。 最后，如果你看到以下信息，说明连接成功。 Hi USERNAME! You&apos;ve successfully authenticated, but GitHub does not provide shell access.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客迁移]]></title>
      <url>%2F2016%2F04%2F29%2F16-04-29-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%2F</url>
      <content type="text"><![CDATA[原来的博客地址：http://irena.gitcafe.io现在的博客地址：http://irenachou.github.io/ 第一次搭博客首选了gitcafe，是因为gitcafe访问相对快一些，github比较慢，转了一圈，最终又回到了github上来。 前两天写了一篇关于UI-Touch的小短文发现gitcafe被coding收购了，5月31号前要把所有gitcafe上的项目都迁移到coding，接着就始迁移了，在coding部署要交费了，试了几天，实在很贵，也没有找到比较好的较便宜的方法，又放弃coding向github上迁移 迁移的过程中还是遇到了一个小问题，以前在gitcafe的时候，使用的是gitcafe-pages子分支，也就想在github上直接使用这个子分支，但是将默认分支改成子分支后，访问的还是master分支，英文很烂，并且各种搜索后无解，最后只好曲线救国，先将博客指定到了master分支，有知道我问题的朋友，留言告诉我哦，谢谢了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[coreImage图片滤镜处理]]></title>
      <url>%2F2016%2F04%2F29%2F16-04-29-coreImageDemo%2F</url>
      <content type="text"><![CDATA[参考 CoreImage 是一种图像处理和分析技术，为图片和视频图像提供近实时处理。图像数据类型从核心图形核心视频和图像的I / O框架，可使用GPU或CPU渲染路径。核心图像通过提供一个易于使用的应用程序接口（接口），隐藏低级别图形处理的细节。你不需要知道OpenGL和OpenGLES的细节，利用GPU的能力，你也不需要知道任何关于Grand Central Dispatch（GCD）得到的多核处理的效益。核心图像为你处理细节。 CIContext： 所有图像处理都是在一个CIContext 中完成的，这很像是一个Core Image处理器或是OpenGL的上下文。 CIImage： 这个类保存图像数据。它可以从UIImage、图像文件、或者是像素数据中构造出来。 CIFilter： 滤镜类包含一个字典结构，对各种滤镜定义了属于他们各自的属性。滤镜有很多种，比如鲜艳程度滤镜，色彩反转滤镜，剪裁滤镜等等。 Core Image架构Core Image有一个插件架构，这意味着它允许用户编写自定义的滤镜并与系统提供的滤镜集成来扩展其功能。我们在这篇文章中不会用到Core Image的可扩展性；我提到它只是因为它影响到了框架的API。 包含了Core Image提供的图像滤镜的完整列表，以及用法示例。 无回路有向图 一个滤镜图表是一个链接在一起的滤镜网络（无回路有向图），使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。我们将在下面看到如何连接滤镜来创建一个复古的拍照效果。 Core Image Filter Reference包含了Core Image提供的图像滤镜的完整列表，以及用法示例。 本文中的Demo使用iOS9.3测试Demo包含两个: 一个是单纯的基本滤镜的处理 另一个是照相,图片压缩和简单滤镜处理 Demo代码下载下面附上本人比较喜欢的几个滤镜的效果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UITouch-跟着手指走－判断point的范围]]></title>
      <url>%2F2016%2F04%2F22%2Fuitouch%2F</url>
      <content type="text"><![CDATA[响应者对象 在iOS中不是任何对象都能处理事件,只有继承了UIResponder的对象才能接收并处理事件.我们称之为&quot;响应者对象&quot;. UIApplication,UIViewController,UIView都继承自UIResponder,因此它们都是响应者对象,都能够接收并处理事件. UIResponderUIResponder内部提供了方法来处理事件; &gt; 触摸事件 一次完成的触摸过程,会经历3个状态; UIView的触摸事件处理1、一根或多根手指开始触摸view,系统会自动调用view下面的方法: (void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event; //触摸开始 2、一根或者多根手指在view上移动，系统会自动调用view下面的方法（随着手指的移动，会持续调用该方法）: (void)touchesMoved:(NSSet )touches withEvent:(UIEvent )event; //触摸移动 3、一根或者多根手指离开view，系统会自动调用view下面的方法： (void)touchesEnded:(NSSet )touches withEvent:(UIEvent )event; //触摸结束 4、触摸结束前，某个系统事件（例如电话呼入）会打断触摸过程，系统会自动调用view下面的方法 (void)touchesCancelled:(NSSet )touches withEvent:(UIEvent )event; //触摸取消(可能会经历) 4个触摸事件的处理方法中，都有 NSSet touches 和 UIEvent event 两个参数； 1、一次完整的触摸过程，只会产生一个事件对象，4个触摸方法都是同一个event参数； 2、如果两根手指同时触摸一个view，那么view只会调用一次 touchesBegan:withEvent: 方法，touches参数中装着两个UITouch对象； 3、如果这两根手指一前一后分开触摸同一个view，那么view会分别调用两次 touchesBegan:withEvent:方法， 并且每次调用时的touches参数只包含一个UITouch对象； 4、根据touches中UITouch个数可以判断出使单点触摸还是多点触摸。 提示：touches中存放的都是UITouch对象。 下面提供一个简单的Demo，view跟着手指移动 点击下载Demo 下面提供一个简单的Demo，view由手指拖着走，并且不能超出屏幕范围 点击下载Demo UITouch类中包含如下成员函数：当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象；一根手指对应一个UITouch对象； UITouch的作用:保存跟手指相关的信息，比如触摸的位置、时间、阶段； 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指的触摸位置； 当手指离开屏幕时，系统会销毁相应的UITouch对象。 提示：iPhone开发中，要避免使用双击事件。 (CGPoint)locationInView:(UIView *)view：函数返回一个CGPoint类型的值，表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的是触摸点在整个窗口的位置。 (CGPoint)previousLocationInView:(UIView *)view：该方法记录了前一个坐标值，函数返回也是一个CGPoint类型的值， 表示触摸在view这个视图上的位置，这里返回的位置是针对view的坐标系的。调用时传入的view参数为空的话，返回的是触摸点在整个窗口的位置。 可使用UITouch的如上两个方法判断方向 可使用这个方法，判断point的否在[self.ball frame]范围内 if (CGRectContainsPoint([self.ball frame], point)){} 触摸事件的产生：1&gt; 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中； 2&gt; UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）； 3&gt; 主窗口会在视图层次结构中找到一个最合适的视图控件来处理触摸事件，这也是整个事件处理过程的第一步； 4&gt; 找到合适的视图控件后，就会调用视图控件的touches方法来做具体的事件处理。 触摸事件的传递：触摸事件的传递是从父控件传递到子控件； 如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件。 UIView不接收触摸事件的三种情况：1&gt; 不接受用户交互 ：userInteractionEnable = NO; 2&gt; 隐藏 ：hidden = YES; 3&gt; 透明：alpha = 0.0 ~ 0.01 UIEvent每产生一个事件，就会产生一个UIEvent对象； UIEvent:称为事件对象，记录事件产生的时刻和类型。 1234567891011121314151617181920#import "ViewController.h"@interface ViewController ()@property(weak, nonatomic) IBOutlet UIView *ball;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.ball.userInteractionEnabled = NO;&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:touch.view]; _ball.center = point;&#125;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:touch.view]; _ball.center = point;&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS判断NSString是否为纯数字]]></title>
      <url>%2F2016%2F04%2F15%2FStringIsNumber%2F</url>
      <content type="text"><![CDATA[123456//判断是否为整形- (BOOL)stringIsPureNumber:(NSString*)string &#123; NSScanner* scan = [NSScanner scannerWithString:string]; int val; return [scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd];&#125; 123456 //判断是否为浮点型- (BOOL)floatIsPureFloat:(NSString*)string &#123; NSScanner* scan = [NSScanner scannerWithString:string]; float val; return [scan scanFloat:&amp;val] &amp;&amp; [scan isAtEnd];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CGPoint]]></title>
      <url>%2F2016%2F04%2F12%2Fcgpoint%2F</url>
      <content type="text"><![CDATA[CGPoint表示一个二维坐标系中的点CGPoint通过x和y坐标定义，可使用CGPointMake(x，y)创建点。 可以将它们与字符串进行相互转换，可用如下函数：NSStringFromCGPoint()、CGPointFromString(). 主要说CGPointFromString方法 下面是CGPoint的定义123456/* Points. */struct CGPoint &#123; CGFloat x; CGFloat y;&#125;;typedef struct CGPoint CGPoint; stringWithFormat从String转换为point的方法中，所需的string格式是{x,y},下面是例子1234NSString *str = @"0.111, 1.22";str = [NSString stringWithFormat:@"&#123;%@&#125;", str];CGPoint initPath = CGPointFromString(str);NSLog(@"%@", NSStringFromCGPoint(initPath));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 3D Touch]]></title>
      <url>%2F2016%2F04%2F11%2F3DTouch%2F</url>
      <content type="text"><![CDATA[3D Touch说明轻压和重压(Peek and Pop)主屏幕快捷操作(Home Screen Quick Actions) 3D Touch 给 iOS 9 用户提供了一个新的交互维度。在所支持3DTouch的设备上，人们可以通过按压应用的图标去快速选择应用定制的操作。在应用内，人们可以使用多种按压操作去获取一个项目的预览，可以在独立的视图里打开一个项获取相关操作。(了解更多在你的代码中如何添加3D Touch支持，参阅 Adopting 3D Touch on iPhone .) 系统会自动安排图标在快速操作列表中的位置是在左侧或者在右侧，这依赖于你的应用的图标在用户主屏幕的位置。(摒除图标在列表中的位置，在自左向右的语言中文字总是左对齐。)这里有主屏快捷操作的多种展现方式的例子。 使用主屏幕快捷操作去开启引人注目的、高价值的任务。例如，Maps可以让用户不需要打开Maps，通过在当前位置附近搜索就可以获得回家的方向。一个应用至少需要把一个有用的任务放在主屏幕快捷操作里；你可以提供最多四个快捷操作 使用3D Touch必须要有6s或6s plus 3D Touch的三大模块home screen quick aactions 静态菜单［不需要写代码，在info.plist中配制］ 动态菜单［代码实现］ 菜单跳转 peek and pop 轻度按压预览页面-peek 大力按压跳转页面-pop peek过程中的自定义操作 force propertiesp home screen quick aactions 1、静态菜单设置下载Demo下图中带“＊”号的，key必须设置，值可以没有，如果没有设置，设置菜单的当前cell将不会被显示出来UIApplicationShortcutItems: 副标题 保持标题的简洁不会被切断从而帮助用户快速理解操作是非常重要的。如果你提供的副标题一行显示不全，系统会截断；如果你没有副标题，系统会把一行展示不完全的长标题以两行展现。 图标 UIApplicationShortcutItemIconType 显示的iconType可以参考如下链接和下图(如需swfit去下面链接中查看)iconType当UIApplicationShortcutItemIconType和UIApplicationShortcutItemIconFile两个都设置的时候UIApplicationShortcutItemIconFile的优先级高于UIApplicationShortcutItemIconType 在项目中的info.plist中的配制示例如下图效果如下图 2､动态菜单及跳转下载Demo代码如下123456789101112131415161718192021222324252627282930313233343536373839404142@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; /** * 3D Touch 动态菜单 * 其中一个item就是一个菜单项 */ UIApplicationShortcutItem *shortcutItem1 = [[UIApplicationShortcutItem alloc] initWithType:@"type1" localizedTitle:@"列表"]; //使用系统图标 // UIApplicationShortcutIcon *icon2 = [UIApplicationShortcutIcon // iconWithType:UIApplicationShortcutIconTypeHome]; //使用自定义图标 // UIApplicationShortcutIcon *icon2 = // [UIApplicationShortcutIcon iconWithTemplateImageName:@""]; /** 不设置icon,Title默认靠右 */ UIApplicationShortcutItem *shortcutItem2 = [[UIApplicationShortcutItem alloc] initWithType:@"type2" localizedTitle:@"force touch" localizedSubtitle:@"subtitle 2subtitle 2" icon:[UIApplicationShortcutIcon iconWithTemplateImageName:@""] userInfo:nil]; // /** // 让title默认靠左，但不显示icon // 只要在一个cell中设置其它的title都会靠左显示 // */ // UIApplicationShortcutItem *shortcutItem3 = [[UIApplicationShortcutItem // alloc] // initWithType:@"" // localizedTitle:@"force touch" // localizedSubtitle:@"subtitle 2subtitle 2" // icon:[UIApplicationShortcutIcon // iconWithTemplateImageName:@""] // userInfo:nil]; [UIApplication sharedApplication].shortcutItems = @[ shortcutItem1, shortcutItem2 ]; //, shortcutItem3 return YES;&#125; 1234567891011121314151617181920212223//点击3D Touch 跳到指定的控制器/** * 点击item菜单会调用此方法 * * @param application * @param shortcutItem 被点击的item * @param completionHandler */- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler &#123; //第一个启动的storyboard所指向的是window的根控制器 //获取tabbarctrl UITabBarController *tabBarCtrl = (UITabBarController *)application.keyWindow.rootViewController; if ([shortcutItem.type isEqualToString:@"type1"]) &#123; //点击了列表 tabBarCtrl.selectedIndex = 1; &#125; else if ([shortcutItem.type isEqualToString:@"type2"]) &#123; //点击froce tabBarCtrl.selectedIndex = 0; &#125;&#125; 两种显示效果如下图 peek and pop下载Demopeek代码注意点: ndexPathForRowAtPoint获取到的是以当前cell为0,0点的位置，而不是以tableview为0,0点 此处的方法一定要看清楚，不是convertPoint:toView:是convertPoint:fromView: 123456789101112131415161718192021222324252627首先要实现UIViewControllerPreviewingDelegate协议/** * peek * * @param previewingContext 包含被选中对象的所有信息 * @param location 被选中对象手指所在的location */- (nullable UIViewController *) previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContextviewControllerForLocation:(CGPoint)location &#123; // indexPathForRowAtPoint获取到的是以当前cell为0,0点的位置 //我们需要的是从tableview顶部为0,0点的位置，才可以获取到当前被选中的cell //获取以cell为0,0点的坐标 // NSIndexPath *indexPath = [self.tableView indexPathForRowAtPoint:location]; //转化坐标 // 此处的方法一定要看清楚，不是convertPoint:toView:是convertPoint:fromView: // location = [self.tableView convertPoint:location // toView:[previewingContext sourceView]]; location = [self.tableView convertPoint:location fromView:[previewingContext sourceView]]; NSIndexPath *indexPath = [self.tableView indexPathForRowAtPoint:location]; //根据cell获取数组中的数据 id abc = self.items[indexPath.row]; IrenaPre *pre = [[IrenaPre alloc] init]; pre.item = abc; return pre;&#125; 自定义peek代码12345678910111213141516171819202122232425262728//peek 过程中的自定义操作- (NSArray&lt;id&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems &#123; //创建点赞操作 UIPreviewAction *item1 = [UIPreviewAction actionWithTitle:@"赞" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction *_Nonnull action, UIViewController *_Nonnull previewViewController) &#123; NSLog(@"赞了"); &#125;]; //创建点赞操作 UIPreviewAction *item2 = [UIPreviewAction actionWithTitle:@"举报" style:UIPreviewActionStyleDestructive handler:^(UIPreviewAction *_Nonnull action, UIViewController *_Nonnull previewViewController) &#123; NSLog(@"举报了"); &#125;]; // //添加group的效果可运行看看 // UIPreviewActionGroup *group = [UIPreviewActionGroup actionGroupWithTitle:@"group" style:UIPreviewActionStyleDefault actions:@[ item1, item2 ]]; // return @[ group ]; return @[ item1, item2 ];&#125; 自定义peek后的 poppop是在点出peek后在用力按压一下屏幕后出现的12345678910111213/** * pop * * @param previewingContext 包含被选中对象的所有信息 * @param viewControllerToCommit peek返回的controller */- (void)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit &#123; //跳转到peek的controller // animated在pop时无效 [self.navigationController pushViewController:viewControllerToCommit animated:YES];&#125; 效果如下图 forcegithub 下载Demogithub上下载下来的代码在真机跑会有identifier的问题，您最好将identifier修改identifier将‘-’去掉百度云 下载Demo 按压力度，值范围［0-6.666667］代码主要在demo中的IrenaForce.h/.m类代码如下1234567891011121314151617181920212223242526#import "IrenaForce.h"@interface IrenaForce ()@property(nonatomic, strong) UIBezierPath *path;@end@implementation IrenaForce- (void)drawRect:(CGRect)rect &#123; [[UIColor orangeColor] set]; [self.path fill];&#125;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; //获取触摸对象 UITouch *touch = [touches anyObject]; NSLog(@"%lf", touch.force); //创建路径 //根据压力*系数 手指的位置为圆心画圆 UIBezierPath *path = [[UIBezierPath alloc] init]; [path addArcWithCenter:[touch locationInView:self] radius:touch.force * 20 startAngle:0 endAngle:2 * M_PI clockwise:YES]; self.path = path; //重绘 [self setNeedsDisplay];&#125;@end 效果如下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[制作/使用.a文件]]></title>
      <url>%2F2016%2F04%2F11%2Fa-file-makeAndUse%2F</url>
      <content type="text"><![CDATA[制作步骤： File–New–Project按照如下图创建项目 按照下图创完成所需类的定义和实现 创建后Command + B 进行编辑，如果device选择的是真机，生成的.a文件就适合真机的想要创建适用于模拟器的.a文件，将device改成模拟器就可以 如果没有生成所需头文件，按下图逐步操作添加 按下图查看制作好的.a文件 使用： 将生成的.a文件和.h文件拖到要使用的项目中 直接使用就可以 合并.a文件【将模拟器的.a文件和真机的.a文件整合在一起】1lipo -create IRCode/iOS/iphoneos/libIRTestSDK.a IRCode/iOS/iphonesimulator/libIRTestSDK.a -output IRCode/iOS/libIRTestSDK.a 其中IRCode/iOS/iphoneos/libIRTestSDK.a //为真机库。 IRCode/iOS/iphonesimulator/libIRTestSDK.a //为模拟器库IRCode/iOS/libIRTestSDK.a //为两个合并后存放的路径 然后可以输入命令测试下是否成功 lipo -info IRCode/iOS/libIRTestSDK.a //下面是输出 armv7 i386 有了两个就表情模拟器和真机都支持 其中armv7为真机架构 i386为模拟器Architectures in the fat file: SQY/iOS/libGamePus.a are: armv7 i386]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[标签]]></title>
      <url>%2F2016%2F03%2F30%2FtagView%2F</url>
      <content type="text"><![CDATA[原码下载 OC原码中用了两种方法实现标签功能: 一种是使用collectionView实现 另一种是用draw实现 显示如下图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[显示隐藏tabbar]]></title>
      <url>%2F2016%2F03%2F30%2FtabbarShowOrHidden%2F</url>
      <content type="text"><![CDATA[参考原文 隐藏TabBar：123456789101112- (void)hideTabBar &#123; if (self.tabBarController.tabBar.hidden == YES) &#123; return; &#125; UIView *contentView; if ( [[self.tabBarController.view.subviews objectAtIndex:0] isKindOfClass:[UITabBar class]] ) contentView = [self.tabBarController.view.subviews objectAtIndex:1]; else contentView = [self.tabBarController.view.subviews objectAtIndex:0]; contentView.frame = CGRectMake(contentView.bounds.origin.x, contentView.bounds.origin.y, contentView.bounds.size.width, contentView.bounds.size.height + self.tabBarController.tabBar.frame.size.height); self.tabBarController.tabBar.hidden = YES;&#125; 显示TabBar：1234567891011121314- (void)showTabBar&#123; if (self.tabBarController.tabBar.hidden == NO) &#123; return; &#125; UIView *contentView; if ([[self.tabBarController.view.subviews objectAtIndex:0] isKindOfClass:[UITabBar class]]) contentView = [self.tabBarController.view.subviews objectAtIndex:1]; else contentView = [self.tabBarController.view.subviews objectAtIndex:0]; contentView.frame = CGRectMake(contentView.bounds.origin.x, contentView.bounds.origin.y, contentView.bounds.size.width, contentView.bounds.size.height - self.tabBarController.tabBar.frame.size.height); self.tabBarController.tabBar.hidden = NO;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手电筒]]></title>
      <url>%2F2016%2F03%2F28%2FFlashlight%2F</url>
      <content type="text"><![CDATA[原码下载 1234567#import "ViewController.h"#import &lt;AVFoundation/AVFoundation.h&gt;@interface ViewController ()@property(nonatomic, strong) AVCaptureDevice *device;@property(nonatomic) AVCaptureTorchMode torchModeMe;@property(weak, nonatomic) IBOutlet UISwitch *controlSwitch;@end 12345678910111213141516171819202122232425262728293031@implementation ViewController/** * 开关手电桶 */- (IBAction)onOrOff:(id)sender &#123; // AVCaptureDevice代表抽象的硬件设备 // 返回用于捕获给定媒体类型的数据的默认设备 _device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; //检查设备是否支持手电筒 if (![_device hasTorch]) &#123; NSLog(@"设备不支持手电筒"); return; &#125; if ([sender isOn]) &#123; [self.view setBackgroundColor:[UIColor whiteColor]]; _torchModeMe = AVCaptureTorchModeOn; &#125; else &#123; [self.view setBackgroundColor:[UIColor blackColor]]; _torchModeMe = AVCaptureTorchModeOff; &#125; // lockForConfiguration 来尝试在捕获设备上获取锁 [_device lockForConfiguration:nil]; [_device setTorchMode:_torchModeMe]; //来放弃锁定 [_device unlockForConfiguration];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; [self onOrOff:_controlSwitch];&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查看真机 / 模拟器沙盒]]></title>
      <url>%2F2016%2F03%2F23%2FseeSandboxDirectory%2F</url>
      <content type="text"><![CDATA[查看真机沙盒 查看模拟器沙盒 查看模拟器沙盒，可使用simpholders工具，点击下面的下载，可下载simpholders破解版工具 下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS Rsa]]></title>
      <url>%2F2016%2F03%2F14%2FrsaBase64%2F</url>
      <content type="text"><![CDATA[生成秘匙参考原文 OC Demo 下载 加密图解 本文主要讲解iOS方面的RSA加解密，demo也是针对iOS的加解密，具体demo可由文章最上面点OC Demo下载链接下载 加解密的具体代码较分散，就不一一在文件中展示，如需要可在文章开头下载 其中公钥和私钥文件由下面的这段代码块生成，如果你只包含加密，无需解密，可不使用下面代码块，加密文件服务器由服务器端提供1234#!/usr/bin/env bashecho "Generating RSA key pair ..."echo "2048 RSA key: private_key.pem"openssl genrsa -out private_key.pem 2048 12echo "create certification require file: rsaCertReq.csr"openssl req -new -key private_key.pem -out rsaCertReq.csr 12echo "create certification using x509: rsaCert.crt"openssl x509 -req -days 3650 -in rsaCertReq.csr -signkey private_key.pem -out rsaCert.crt 12echo "create public_key.der For IOS"openssl x509 -outform der -in rsaCert.crt -out public_key.der 12echo "create private_key.p12 For IOS. Please remember your password. The password will be used in iOS."openssl pkcs12 -export -out private_key.p12 -inkey private_key.pem -in rsaCert.crt 12345echo "create rsa_public_key.pem For Java"openssl rsa -in private_key.pem -out rsa_public_key.pem -puboutecho "create pkcs8_private_key.pem For Java"openssl pkcs8 -topk8 -in private_key.pem -out pkcs8_private_key.pem -nocryptecho "finished." Tips:在创建证书的时候, terminal会提示输入证书信息. 根据输入对应信息就OK.在创建p12密匙时, 会提示输入密码, 此时的密码必须记住, 之后解密会用到.如果上面指令有问题,请参考最新的openssl官方文档, 以官方的为准.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[弹框－发送邮件]]></title>
      <url>%2F2016%2F03%2F11%2FsendMailPop%2F</url>
      <content type="text"><![CDATA[调用123456/** * 需要弹框发邮件 */if ([self isSendMail]) &#123; [self sendEmailAction];&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041- (BOOL)isSendMail &#123; Class mailClass = (NSClassFromString(@"MFMailComposeViewController")); if (!mailClass) &#123; NSLog(@"不支持应用内发送邮件功能"); return NO; &#125; //获取用户是否设置了邮件账户： if ([MFMailComposeViewController canSendMail]) &#123; // 用户已设置邮件账户 [self sendEmailAction]; // 调用发送邮件的代码 return NO; &#125; return YES;&#125;- (void)sendEmailAction &#123; // 邮件服务器 MFMailComposeViewController *mailCompose = [[MFMailComposeViewController alloc] init]; // 设置邮件代理 [mailCompose setMailComposeDelegate:self]; // 设置邮件主题 [mailCompose setSubject:@"邮件标题"]; // 设置收件人 [mailCompose setToRecipients:@[ [_emailText text] ]]; /** * 设置邮件的正文内容 */ NSString *emailContent = @"邮件内容"; [mailCompose setMessageBody:emailContent isHTML:NO]; /** * 添加附件 */ // UIImage *image = [UIImage imageNamed:@"image"]; NSData *imageData = UIImagePNGRepresentation(_image); [mailCompose addAttachmentData:imageData mimeType:@"" fileName:@"custom." @"png"]; // 弹出邮件发送视图 [self presentViewController:mailCompose animated:YES completion:nil];&#125; 123456789101112131415161718192021// MFMailComposeViewControllerDelegate的代理方法：- (void)mailComposeController:(MFMailComposeViewController *)controller didFinishWithResult:(MFMailComposeResult)result error:(NSError *)error &#123; switch (result) &#123; case MFMailComposeResultCancelled: // 用户取消编辑 NSLog(@"Mail send canceled..."); break; case MFMailComposeResultSaved: // 用户保存邮件 NSLog(@"Mail saved..."); break; case MFMailComposeResultSent: // 用户点击发送 NSLog(@"Mail sent..."); break; case MFMailComposeResultFailed: // 用户尝试保存或发送邮件失败 NSLog(@"Mail send errored: %@...", [error localizedDescription]); break; &#125; // 关闭邮件发送视图 [self dismissViewControllerAnimated:YES completion:nil];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[验证手机号和银行卡号]]></title>
      <url>%2F2016%2F03%2F11%2FisValidateBankCardAndMobile%2F</url>
      <content type="text"><![CDATA[12//判断一个号码是否为手机号码BOOL isValidateMobile(NSString *mobile); 12//判断是否为一个合法的银行卡号BOOL isValidateBankCard(NSString *bankNo); 12345678/*手机号码验证*/BOOL isValidateMobile(NSString *mobile) &#123; //手机号以13, 15,18开头,八个 \d 数字字符 NSString *phoneRegex = @"^((13[0-9])|(15[^4,\\D])|(18[0,0-9]))\\d&#123;8&#125;$"; NSPredicate *phoneTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", phoneRegex]; return [phoneTest evaluateWithObject:mobile];&#125; 12345678// 判断银行卡BOOL isValidateBankCard(NSString *bankCard) &#123; NSString *cardRegex = @"/^\\d&#123;16,19&#125;$|^\\d&#123;6&#125;\\d&#123;10,13&#125;$|^\\d&#123;4&#125;\\d&#123;4&#125;\\d&#123;4&#125;\\d&#123;4,7&#125;$/"; NSPredicate *bankTest = [NSPredicate predicateWithFormat:@"SELF MATCHES %@", cardRegex]; return [bankTest evaluateWithObject:bankCard];&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[空值判断]]></title>
      <url>%2F2016%2F03%2F11%2FisNotNULL%2F</url>
      <content type="text"><![CDATA[12//空值判断BOOL isNotNULL(id object); 123456789101112BOOL isNotNULL(id object) &#123; if ([object isKindOfClass:[NSNull class]]) &#123; return NO; &#125; else if ([object isKindOfClass:[NSString class]]) &#123; if ([object isEqualToString:@"(null)"]) &#123; return NO; &#125; &#125; else if (!object) &#123; return NO; &#125; return YES;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[更改Mac OS X登陆密码]]></title>
      <url>%2F2016%2F03%2F09%2FupdateLoginPassword%2F</url>
      <content type="text"><![CDATA[重设Mac OS X开机密码 关闭 Mac。如有需要，请按住电源按钮直到 Mac 强制关机。 按（但不用按住）电源按钮启动 Mac，然后立即按住键盘上的 Command-R。 看到 Apple 标志出现后，您可以松开在上一步中按住的按键。 恢复系统屏幕出现后，请选取“实用工具”&gt;“终端”。 在“终端”中，输入此命令并按下 Return 键以打开“重设密码”实用工具：resetpassword “重设密码”实用工具窗口应会出现。 重设密码 按照“重设密码”实用工具中的这些步骤来重设用户帐户的密码。 在“重设密码”实用工具窗口中，选择密码需重设的用户帐户所在的宗卷。例如，如果客户使用的是默认启动磁盘，则选择“Macintosh HD”。 从“选择用户帐户：”弹出式菜单中选择该用户帐户。 在“请为此用户输入一个新密码”字段中输入新密码。 在“请再一次输入此用户的新密码”栏中输入完全相同的密码。 在“为此用户输入新的密码提示（可选）”栏中输入可选的密码提示。 点按“存储”。 在“重设登录密码”对话框中点按“好”。记下此对话框中的重要信息。 关闭“重设密码”窗口。 从 Apple 菜单中选择“重新启动”。电脑启动后，请登录到您重设的用户帐户来确认您创建的新密码已经起作用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[applePayDemo]]></title>
      <url>%2F2016%2F03%2F04%2FapplePayDemo%2F</url>
      <content type="text"><![CDATA[参考原文 定义1234#import "ViewController.h"#import &lt;PassKit/PassKit.h&gt;@interface ViewController ()&lt;PKPaymentAuthorizationViewControllerDelegate&gt;@end 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad];&#125;- (void)applePayTest &#123; //设备可用 // PKPaymentAuthorizationViewController用来显示ApplePay的Controller if (![PKPaymentAuthorizationViewController canMakePayments]) &#123; //设备不支持 //不让ApplePay的支付按钮去显示 return; &#125; //想当自己的应用支持的卡类型 /* [PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[PKPaymentNetworkVisa]] */ //判断支持的卡类型 if (![PKPaymentAuthorizationViewController canMakePaymentsUsingNetworks:@[ PKPaymentNetworkVisa, PKPaymentNetworkChinaUnionPay ]]) &#123; NSLog(@"不支持visa和银联"); //进入设置银行卡的页面 [[[PKPassLibrary alloc] init] openPaymentSetup]; return; &#125; //创建支付请求 PKPaymentRequest *request = [[PKPaymentRequest alloc] init]; //显示支付页面 PKPaymentAuthorizationViewController *vc = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:request]; vc.delegate = self; //*设置商户的ID(网站配制的id) request.merchantIdentifier = @"merchant.com.irena.AppleiPayDemo"; //*设置国家代码 request.countryCode = @"CN"; //*设置支付的卡类型 request.supportedNetworks = @[ PKPaymentNetworkVisa ]; //*设置商户的支付标准(必须支持3DS) request.merchantCapabilities = PKMerchantCapability3DS; //*设置货币单位(中文CNY) request.currencyCode = @"CNY"; 1234567891011121314151617181920212223242526272829303132 //*设置商品 // label商品名称 // amount价格 NSDecimalNumber *num1 = [NSDecimalNumber decimalNumberWithString:@"4"]; // 当只有一个1个商品时,显示的是付给当前商品 PKPaymentSummaryItem *item1 = [PKPaymentSummaryItem summaryItemWithLabel:@"水杯" amount:num1]; PKPaymentSummaryItem *item2 = [PKPaymentSummaryItem summaryItemWithLabel:@"红牛" amount:num1]; //当多个时商品,最后一个商品被当成一个总价去显示 NSDecimalNumber *sum = [NSDecimalNumber decimalNumberWithString:@"8"]; PKPaymentSummaryItem *itemSum = [PKPaymentSummaryItem summaryItemWithLabel:@"zdjr" amount:sum]; request.paymentSummaryItems = @[ item1, item2, itemSum ]; //设置收据必填内容,第一次使用必填 request.requiredBillingAddressFields = PKAddressFieldAll; // billingContact 默认地址 //设置送货必填的内容 request.requiredShippingAddressFields = PKAddressFieldAll; //设置送货方式 // summaryItemWithLabel 送货方式 NSDecimalNumber *methodNum = [NSDecimalNumber decimalNumberWithString:@"4"]; PKShippingMethod *method1 = [PKShippingMethod summaryItemWithLabel:@"顺风" amount:methodNum]; //*区分同一个送货方式,必须填 method1.identifier = @"shunfeng"; //送货方式的详情描述 method1.detail = @"24小时之内送到"; request.shippingMethods = @[ method1 ]; // modal出来,显示支付页面 [self presentViewController:vc animated:YES completion:nil];&#125; PKPaymentAuthorizationViewControllerDelegate1234567891011121314151617181920212223242526272829303132333435/*在点击"使用密码支付"的按钮时候调用,开始进行支付调用 payment:加密后的数据 */- (void)paymentAuthorizationViewController: (PKPaymentAuthorizationViewController *)controller didAuthorizePayment:(PKPayment *)payment completion: (void (^)(PKPaymentAuthorizationStatus status)) completion &#123; //把支付信息发送给服务器进行处理 //第三方或发送给自己的服务器 //银连https://merchant.unionpay.com/join/product/detail?id=80 // NSError *error; // ABMultiValueRef addressMultiValue = // ABRecordCopyValue(payment.billingAddress,kABPersonAddressProperty); // NSDictionary *addressDictionary = (__bridge_transfer NSDictionary *) // ABMultiValueCopyValueAtIndex(addressMultiValue, 0); // NSData *json = [NSJSONSerialization dataWithJSONObject:addressDictionary // options:NSJSONWritingPrettyPrinted error: &amp;error]; //根据服务器返回的支付状态进行不同的显示,给用户进行不同的显示 //(调用BLOCK传不同的枚举) completion(PKPaymentAuthorizationStatusSuccess);&#125;/* 支付完成 支付成功或失败后调用的方法 */- (void)paymentAuthorizationViewControllerDidFinish: (PKPaymentAuthorizationViewController *)controller &#123; //把支付的界面关闭 [self dismissViewControllerAnimated:YES completion:nil];&#125;@end 暂时只提Demo，后序在完善]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[问题记录]]></title>
      <url>%2F2016%2F03%2F01%2Fbug1%2F</url>
      <content type="text"><![CDATA[如下错误是没有rootViewController，我平时并不这么写12345678- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; [self.window addSubview:controller.view]; [self.window makeKeyAndVisible]; return YES;&#125; 错误：12345*** Assertion failure in -[UIApplication _runWithMainScene:transitionContext:completion:], /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit/UIKit-3512.30.14/UIApplication.m:3315*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Application windows are expected to have a root view controller at the end of application launch'*** First throw call stack:(0x1821c5900 0x181833f80 0x1821c57d0 0x182b3899c 0x187160ac0 0x18715d5c0 0x18377b790 0x18377bb10 0x18217cefc 0x18217c990 0x18217a690 0x1820a9680 0x186f26580 0x186f20d90 0x1000de108 0x181c4a8b8)libc++abi.dylib: terminating with uncaught exception of type NSException 解决方法： 设置rootViewController1[self.window setRootViewController:[UIViewController new]];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS渐变颜色可设置渐变方向]]></title>
      <url>%2F2016%2F03%2F01%2FgradientColor%2F</url>
      <content type="text"><![CDATA[参考原文 12345678910111213#import &lt;UIKit/UIKit.h&gt;//渐变方向typedef NS_ENUM(NSUInteger, GradientType) &#123; GradientTypeTopToBottom = 0, //从上到小 GradientTypeLeftToRight = 1, //从左到右 GradientTypeUpleftToLowright = 2, //左上到右下 GradientTypeUprightToLowleft = 3, //右上到左下&#125;;@interface UIImage (GradientColor)+ (UIImage *)gradientColorImageFromColors:(NSArray *)colors gradientType:(GradientType)gradientType imgSize:(CGSize)imgSize;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#import "UIImage+GradientColor.h"@implementation UIImage (GradientColor)+ (UIImage *)gradientColorImageFromColors:(NSArray *)colors gradientType:(GradientType)gradientType imgSize:(CGSize)imgSize &#123; NSMutableArray *colorsArray = [NSMutableArray array]; for (UIColor *color in colors) &#123; [colorsArray addObject:(id)color.CGColor]; &#125; UIGraphicsBeginImageContextWithOptions(imgSize, YES, 1); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSaveGState(context); CGColorSpaceRef colorSpace = CGColorGetColorSpace([[colors lastObject] CGColor]); CGGradientRef gradient = CGGradientCreateWithColors(colorSpace, (CFArrayRef)colorsArray, NULL); CGPoint start; CGPoint end; switch (gradientType) &#123; case GradientTypeTopToBottom: start = CGPointMake(0.0, 0.0); end = CGPointMake(0.0, imgSize.height); break; case GradientTypeLeftToRight: start = CGPointMake(0.0, 0.0); end = CGPointMake(imgSize.width, 0.0); break; case GradientTypeUpleftToLowright: start = CGPointMake(0.0, 0.0); end = CGPointMake(imgSize.width, imgSize.height); break; case GradientTypeUprightToLowleft: start = CGPointMake(imgSize.width, 0.0); end = CGPointMake(0.0, imgSize.height); break; default: break; &#125; CGContextDrawLinearGradient(context, gradient, start, end, kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); CGGradientRelease(gradient); CGContextRestoreGState(context); CGColorSpaceRelease(colorSpace); UIGraphicsEndImageContext(); return image;&#125;@end 使用1234567UIColor *topleftColor = [UIColor colorWithHexString:@"4fc2e9"];UIColor *bottomrightColor = [UIColor colorWithHexString:@"0379b2"];UIImage *bgImg = [UIImage gradientColorImageFromColors:@[ topleftColor, bottomrightColor ] gradientType:GradientTypeLeftToRight imgSize:kScreenSize];[UITabBar appearance].barTintColor = [UIColor colorWithPatternImage:bgImg];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS在程序中控制系统的屏幕亮度]]></title>
      <url>%2F2016%2F03%2F01%2FbrightNess%2F</url>
      <content type="text"><![CDATA[参考原文 12// 0 .. 1.0, where 1.0 is maximum brightness. Only supported by main screen.@property(nonatomic) CGFloat brightness NS_AVAILABLE_IOS(5_0) __TVOS_PROHIBITED; 12345//获取系统屏幕当前的亮度值CGFloat value = [UIScreen mainScreen].brightness;//设置系统屏幕亮度值value += 0.8;[[UIScreen mainScreen] setBrightness:value];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用U盘装MAC OS X]]></title>
      <url>%2F2016%2F02%2F29%2FmacInstallWithUdisk%2F</url>
      <content type="text"><![CDATA[我装的是OS X EI Capitan有两种方法：一，网络恢复 必须在能用国外的网的基础上才可以（我是开的vpn），我选择的是第二种方法二，将U盘设置成启动盘，直接安装 安装的先决条件 准备一个不小到8G的盘 将盘插入电脑的usb口中，打开磁盘工具 将盘抹掉，如下图 继续上面的步骤： 从App Store下载完整的 OS X 安装器（就是重新下一下） 一定要将如下文件放到finder-application(应用程序中) 这个文件一般由双击.dmg包打开后就可以看见 然后在终端执行如下代码，下面代码中的123为盘的名称 终端:sudo /Applications/Install\ OS\ X\ El\ Capitan.app/Contents/Resources/createinstallmedia --volume /Volumes/123 --applicationpath /Applications/Install\ OS\ X\ El\ Capitan.app 将上面的代码粘贴到终端后回车，会让选择y或n，输入y 需要等待一会我大概是30分钟左右吧 完成后推出磁盘 使用u盘安装 将u盘插到电脑上 重启电脑，一直按option(alt)键 选择你的安装盘 继续… 你可能会出现如下问题 不能验证这个“安装 os x ei capitan”应用程序副本,它在下载过程中可能已遭破坏 这个问题的解决方法就是，系统时间改成OS X EI Capitan安装包右面的时间，重启安装即可 修改时间的终端命令：date 100114102015.30 10是月，01是日，14是时，10是分，2015是年，30是秒 注意:只要年月日一样就行 遇到问题的解决： 给苹果打电话求助 *电话：400-666-8800* 使用搜索引擎 （就是不管他问题说的多明显，一定要先百度，因为有可能和你想的并不相同）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[appleDeveloperAccount 苹果IOS开发者账号]]></title>
      <url>%2F2016%2F02%2F25%2FappleDeveloperAccount%2F</url>
      <content type="text"><![CDATA[参考原文 个人账号（Individual）：费用99美金一年, 该账号在App Store销售者只能显示个人的ID，比如zhitian zhang，单人使用。个人账号只能有一个开发者。100个苹果的iOS设备UDID测试。 公司团队账号 （Company/Organization）：费用99美金一年, 该账号在App Store销售者可以显示类似Studios，或者自定义的团队名称，比如Mamshare INC，公司账号可以允许多个开发者协作开发，比个人多一些帐号管理的设置，可以设置多个AppleID，分4种管理级别权限，详细见备注。100个苹果的iOS设备UDID测试。但是申请时需要填写公司的邓白氏编码（D-U-N-S）。 备注： Admin Legal权限：超级管理员。可以管理开发者和管理app store中的应用。 Admin 权限：管理员，可以管理开发者。添加测试机子和管理团队证书。 Member权限：是普通开发者。只能下载证书和使用证书 No Access权限：没有相应的权限。 申请公司团队账号地址 邓白氏编码（D-U-N-S 企业账号 （Enterprise）费用299美金一年, 该账号开发应用不能发布到App Store，只能企业内部应用，苹果的iOS设备UDID数量不限制。企业账号适合不希望上线App Store，但是需要企业内部比如1000人的iOS设备都部署。公司测试部门需要全公司测试设备，突破100个UDID的限制。 教育账号(University)费用0美元 ，只能教育机构或学院内部使用。必须是苹果iOS开发者计划授权机构。不能对外正式发布iOS应用程序。 备注申请地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[绘制虚线]]></title>
      <url>%2F2016%2F02%2F24%2FdrawDashLine%2F</url>
      <content type="text"><![CDATA[参考原文 绘制虚线方法12345678910111213141516171819202122232425262728293031323334353637/** ** lineView: 需要绘制成虚线的view ** lineLength: 虚线的宽度 ** lineSpacing: 虚线的间距 ** lineColor: 虚线的颜色 **/+ (void)drawDashLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor &#123; CAShapeLayer *shapeLayer = [CAShapeLayer layer]; [shapeLayer setBounds:lineView.bounds]; [shapeLayer setPosition:CGPointMake(CGRectGetWidth(lineView.frame) / 2, CGRectGetHeight(lineView.frame))]; [shapeLayer setFillColor:[UIColor clearColor].CGColor]; // 设置虚线颜色为blackColor [shapeLayer setStrokeColor:lineColor.CGColor]; // 设置虚线宽度 [shapeLayer setLineWidth:CGRectGetHeight(lineView.frame)]; [shapeLayer setLineJoin:kCALineJoinRound]; // 设置线宽，线间距 [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]]; // 设置路径 CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, NULL, 0, 0); CGPathAddLineToPoint(path, NULL, CGRectGetWidth(lineView.frame), 0); [shapeLayer setPath:path]; CGPathRelease(path); // 把绘制好的虚线添加上来 [lineView.layer addSublayer:shapeLayer];&#125; 使用1234[ViewController drawDashLine:self.lineView lineLength:10 lineSpacing:2.0 lineColor:[UIColor colorWithHexString:@"393939"]]; 绘制虚线【竖线】123456789101112131415161718192021222324252627282930313233343536373839/** * 绘制虚线【竖线】 * * @param lineView 需要绘制成虚线的view * @param lineLength 虚线的宽度 * @param lineSpacing 虚线的间距 * @param lineColor 虚线的颜色 */+ (void)drawDashVerticalLine:(UIView *)lineView lineLength:(int)lineLength lineSpacing:(int)lineSpacing lineColor:(UIColor *)lineColor &#123; CAShapeLayer *shapeLayer = [CAShapeLayer layer]; [shapeLayer setBounds:lineView.bounds]; [shapeLayer setPosition:CGPointMake(CGRectGetWidth(lineView.frame), CGRectGetHeight(lineView.frame) * 0.5)]; [shapeLayer setFillColor:[UIColor clearColor].CGColor]; // 设置虚线颜色为blackColor [shapeLayer setStrokeColor:lineColor.CGColor]; // 设置虚线宽度 [shapeLayer setLineWidth:lineLength]; [shapeLayer setLineJoin:kCALineJoinRound]; // 设置线宽，线间距 [shapeLayer setLineDashPattern:[NSArray arrayWithObjects:[NSNumber numberWithInt:lineLength], [NSNumber numberWithInt:lineSpacing], nil]]; // 设置路径 CGMutablePathRef path = CGPathCreateMutable(); CGPathMoveToPoint(path, NULL, 0, 0); CGPathAddLineToPoint(path, NULL, 0, lineView.frame.size.height); [shapeLayer setPath:path]; CGPathRelease(path); // 把绘制好的虚线添加上来 [lineView.layer addSublayer:shapeLayer];&#125; category下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[十六进制颜色转换成UIColor]]></title>
      <url>%2F2016%2F02%2F24%2FhexStringConvertUIColor%2F</url>
      <content type="text"><![CDATA[原文出自 interface123@interface UIColor (hex) + (UIColor *)colorWithHexString:(NSString *)stringToConvert;@end implementation1234567891011121314#import &lt;QuartzCore/QuartzCore.h&gt;#define DEFAULT_VOID_COLOR [UIColor whiteColor]@implementation UIColor (hex)+ (UIColor *)colorWithHexString:(NSString *)stringToConvert &#123; NSString *cString = [[stringToConvert stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString]; if ([cString length] &lt; 6) return DEFAULT_VOID_COLOR; if ([cString hasPrefix:@"#"]) cString = [cString substringFromIndex:1]; if ([cString length] != 6) return DEFAULT_VOID_COLOR; 123456789101112131415161718 NSRange range; range.location = 0; range.length = 2; NSString *rString = [cString substringWithRange:range]; range.location = 2; NSString *gString = [cString substringWithRange:range]; range.location = 4; NSString *bString = [cString substringWithRange:range]; unsigned int r, g, b; [[NSScanner scannerWithString:rString] scanHexInt:&amp;r]; [[NSScanner scannerWithString:gString] scanHexInt:&amp;g]; [[NSScanner scannerWithString:bString] scanHexInt:&amp;b]; return [UIColor colorWithRed:((float)r / 255.0f) green:((float)g / 255.0f) blue:((float)b / 255.0f) alpha:1.0f];&#125;@end 使用1[UIColor colorWithHexString:@"4fc2e9"]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[capturePicture 截取scrollView和屏幕显示的图片]]></title>
      <url>%2F2016%2F02%2F16%2FcapturePicture%2F</url>
      <content type="text"><![CDATA[一、获取当前屏幕显示的图片1234UIGraphicsBeginImageContextWithOptions(_scrollView.contentSize, YES, 1);[_scrollView.layer renderInContext:UIGraphicsGetCurrentContext()];UIImage *uiImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext(); 二、获取scrollView的contentSize包含的图片 1234567891011121314151617181920- (UIImage *)captureScrollView:(UIScrollView *)scrollView &#123; UIImage *image = nil; UIGraphicsBeginImageContext(scrollView.contentSize); &#123; CGPoint savedContentOffset = scrollView.contentOffset; CGRect savedFrame = scrollView.frame; scrollView.contentOffset = CGPointZero; scrollView.frame = CGRectMake(0, 0, scrollView.contentSize.width, scrollView.contentSize.height); [scrollView.layer renderInContext:UIGraphicsGetCurrentContext()]; image = UIGraphicsGetImageFromCurrentImageContext(); scrollView.contentOffset = savedContentOffset; scrollView.frame = savedFrame; &#125; UIGraphicsEndImageContext(); if (image != nil) &#123; return image; &#125; return nil;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sendMail 发邮件]]></title>
      <url>%2F2016%2F02%2F16%2FsendMail%2F</url>
      <content type="text"><![CDATA[使用SKPSMTPMessage无需弹框发送邮件123456789101112131415//使用SKPSMTPMessage无需弹框发送邮件我使用的是1.导入头文件#import "NSData+Base64Additions.h"#import "SKPSMTPMessage.h" SKPSMTPMessage *mail = [[SKPSMTPMessage alloc] init]; [mail setSubject:@"标题"]; // 设置邮件主题 [mail setToEmail:@".com"]; // 目标邮箱 [mail setFromEmail:@".com"]; // 发送者邮箱 [mail setRelayHost:@"smtp.qq.com"]; // 发送邮件代理服务器 [mail setRequiresAuth:YES]; [mail setLogin:@".com"]; // 发送者邮箱账号 [mail setPass:@""]; // 发送者邮箱密码 [mail setWantsSecure:YES]; // 需要加密 [mail setDelegate:self]; 1234567891011121314151617181920212223242526272829303132 //设置邮件正文内容： NSString *content = [NSString stringWithCString:"邮件内容" encoding:NSUTF8StringEncoding]; NSDictionary *plainPart = @&#123; kSKPSMTPPartContentTypeKey : @"text/plain", kSKPSMTPPartMessageKey : content, kSKPSMTPPartContentTransferEncodingKey : @"8bit" &#125;; // 添加附件 NSString *vcfPath = [[NSBundle mainBundle] pathForResource:@"test" ofType:@"png"]; NSData *vcfData = [NSData dataWithContentsOfFile:vcfPath];// _image 截取的图片 vcfData = UIImagePNGRepresentation(_image); NSDictionary *vcfPart = [NSDictionary dictionaryWithObjectsAndKeys: @"text/directory;\r\n\tx-unix-mode=0644;\r\n\tname=\"test.png\"", kSKPSMTPPartContentTypeKey, @"attachment;\r\n\tfilename=\"test.png\"", kSKPSMTPPartContentDispositionKey, [vcfData encodeBase64ForData], kSKPSMTPPartMessageKey, @"base64", kSKPSMTPPartContentTransferEncodingKey, nil]; // 执行发送邮件代码： [mail setParts:@[ plainPart, vcfPart ]]; // 邮件首部字段、邮件内容格式和传输编码 [mail send];#pragma SKPSMTPMessage 代理方法- (void)messageSent:(SKPSMTPMessage *)message &#123; NSLog(@"%@", message);&#125;- (void)messageFailed:(SKPSMTPMessage *)message error:(NSError *)error &#123; NSLog(@"message - %@\nerror - %@", message, error);&#125; skpsmtpmessage邮件标题中文乱码问题解决主题使用中文乱码问题 SKPSMTPMessage.m的sendParts里:修改: 123NSData *messageData = [message dataUsingEncoding:NSASCIIStringEncoding allowLossyConversion:YES];为NSData *messageData = [message dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[D-U-N-S(邓白氏编码)申请]]></title>
      <url>%2F2016%2F02%2F16%2FdunsApply%2F</url>
      <content type="text"><![CDATA[公司版和企业版的 Apple开发者帐户申请需要您提交邓白氏号码。申请的表格需要您用 英文或拼音填写。请至 Apple 以下网站以查看贵公司是否已拥有邓白氏编号，如果您有查到任何记录，请确认记录中的公司是否就是贵公司；如果没有查到任何资料或系统调出的记录均不是贵公司的信息，请点击 “Submit Your Information” 提交申请，成功提交至邓白氏公司，他们将会继续协助您获取该编号，申请时间一般需要七个工作日： 申请地址请点击：申请地址 此电话有中文客服4006701855 : 苹果电话02126107504 : duns方负责专门负责被拒的电话 邓白氏公司全球支持部门appdeveloper@dnb.com 各地区 Apple 开发者计划支援电话号码查询 我的申请流程是：邓白氏打电话给申请手机，要可用邮箱邮件的主要内容是填写一下资料 1.公司中英文名： 2.公司办公中英文地址：（注：具体到详细地址） 3.公司邮编：（注：具体到详细邮编） 4.公司主营业务 5.公司企业类型 6.企业是否独立，有无分公司办事处 7.企业有没有英文缩写或者英文简称（没有可不写） 8.联系人姓名，性别，手机，公司电话，职务 9.员工人数规模（请尽量准确，不要填写一个范围，谢谢） 10.营业执照照片. (正本/副本或黑白/彩色都可以) 然后有问题直接跟打给你的电话沟通，或直接邮件回复都可以，我提交的时候公司名称翻译的不规范，他们还帮忙修正了一下 确认后他们会发一下内容24小时内会收到编码,因为是系统自动发的,如果没有收到,您可以联系我. 24小时内系统会自动发编码到苹果注册邮箱内，收到后请14个工作日再去使用。若着急使用,在7个工作日后开始尝试,请注意尝试次数不要超过3次,超过次数编码会被锁住，解锁及注册方面问题请找苹果客服，电话：4006701855]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[suibi]]></title>
      <url>%2F2016%2F01%2F24%2Fsuibi%2F</url>
      <content type="text"><![CDATA[第一篇]]></content>
    </entry>

    
  
  
</search>
